# Type_Safe & Python Formatting Guide for LLMs

- **version**: v3.1.1 
- **updated**: 12th September 2025

## Overview

This guide covers two interconnected systems for writing robust Python code: **OSBot-Utils Type_Safe** and a **specialized Python formatting style**. Type_Safe is a runtime type checking framework that enforces type constraints during execution, catching errors at assignment rather than deep in execution. Unlike Python's type hints (which are ignored at runtime), Type_Safe validates every operation, auto-initializes attributes, and provides domain-specific primitive types for common use cases like IDs, money, URLs, and file paths.

The formatting style prioritizes visual pattern recognition and information density over PEP-8 conventions. It uses vertical alignment to create visual lanes that make code structure immediately apparent, groups related information to maintain context, and optimizes for real-world debugging and code review scenarios. This approach recognizes that code is read far more often than written, and that human pattern recognition is most effective when information is structured consistently and predictably.

## Type_Safe Architecture

### Core Classes Hierarchy

Type_Safe has three foundational classes that power the entire system:

1. **Type_Safe__Base** - Core type checking logic
   - Contains `is_instance_of_type()` method
   - Handles type conversions with `try_convert()`
   - Manages Literal, Union, Optional validation

2. **Type_Safe__Primitive** - Base for safe primitive types
   - Extends built-in types (str, int, float)
   - Caches primitive base type in `__primitive_base__`
   - Overrides arithmetic operators to maintain type safety
   - Provides `__to_primitive__()` for serialization

3. **Type_Safe** - Main class for user schemas
   - Inherits from Type_Safe__Base
   - Provides auto-initialization
   - Handles JSON serialization/deserialization
   - Manages attribute type checking via `__setattr__`

## Critical Principle: Ban Raw Primitives

**NEVER use raw `str`, `int`, or `float` in Type_Safe classes.** There are very few cases where the full capabilities and range of these primitives are actually needed. Raw primitives enable entire categories of bugs and security vulnerabilities.

### Why Ban Raw Primitives?

```python
# ✗ NEVER DO THIS - Raw primitives are dangerous
class User(Type_Safe):
    name   : str        # Can contain SQL injection, XSS, any length
    age    : int        # Can overflow, be negative, be 999999
    balance: float      # Floating point errors in financial calculations

# ✓ ALWAYS DO THIS - Domain-specific types
class User(Type_Safe):
    name   : Safe_Str__Username        # Sanitized, length-limited
    age    : Safe_UInt__Age            # 0-150 range enforced
    balance: Safe_Float__Money         # Exact decimal arithmetic
```

Raw primitives have caused major bugs and security issues:
- **String**: SQL injection, XSS, buffer overflows, command injection
- **Integer**: Overflow bugs, negative values where positive expected
- **Float**: Financial calculation errors, precision loss

## Type_Safe Core Rules

### 1. Always Inherit from Type_Safe
```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class MyClass(Type_Safe):    # ✓ CORRECT
    name  : str
    count : int

class MyClass:                # ✗ WRONG - Missing Type_Safe
    name: str
```

### 2. Type Annotate Everything
```python
class Config(Type_Safe):
    host        : str            # ✓ Every attribute has type
    port        : int
    ssl_enabled : bool
    endpoints   : List[str]      # ✓ Specific generic types
    
    # ✗ WRONG:
    # host = "localhost"      # Missing annotation
    # items: list             # Untyped collection
```

### 3. Immutable Defaults Only
```python
class Settings(Type_Safe):
    name  : str       = ""        # ✓ Immutable
    count : int       = 0         # ✓ Immutable
    items : List[str]             # ✓ No default (Type_Safe handles)
    
    # ✗ NEVER:
    # items: List[str] = []   # Mutable default ERROR
```

### 4. Forward References = Current Class Only
```python
class TreeNode(Type_Safe):
    value  : int
    parent : 'TreeNode' = None    # ✓ Same class
    # parent: 'Node'              # ✗ Different class
```

### 5. Method Validation with @type_safe Decorator
```python
from osbot_utils.type_safe.decorators.type_safe import type_safe

class Calculator(Type_Safe):
    @type_safe                # Validates params and return
    def add(self, a: int, b: int) -> int:
        return a + b
```

The `@type_safe` decorator:
- Validates all parameter types at runtime
- Checks return type matches annotation
- Detects mutable defaults in parameters
- Optimizes away for no-parameter methods (5x overhead vs 250x)
- Powered by `Type_Safe__Method` class internally

## Python Formatting Guidelines

### Method Signatures
```python
def method_name(self, first_param  : Type1        ,                               # Method purpose comment
                      second_param : Type2        ,                               # Aligned at column 80
                      third_param  : Type3 = None                                 # Default values align
                 ) -> ReturnType:                                                 # Return on new line
```

- Parameters stack vertically with opening parenthesis
- **First letter of return type aligns with first letter of parameter names** (the `R` in `ReturnType` aligns with `f` in `first_param`, `s` in `second_param`, etc.)
- Vertical alignment on `:`, `,`, `#`
- Return type format: `) -> ReturnType:` where the closing `)` is positioned to achieve the return type alignment
- Skip formatting for single param or no types/defaults
- ONLY do this when there is at least one parameter: for cases like `method_a(self)` just do `method_a(self) -> ReturnType:`

#### Alignment Example - Focus on Return Type
```python
def process_data(self, input_data   : Dict[str, Any] ,                            # Raw input data
                       validator    : Schema__Validator,                          # Validation schema
                       timeout      : int = 30                                    # Timeout in seconds
                  ) -> Schema__Result:                                            # Processed result
    #                  ^-- Note: 'S' in Schema__Result aligns with 'i' in input_data and 'v' in validator
```

### Variable Assignment & Assertions
```python
# Aligned equals signs
self.node_id    = Random_Guid()
self.value_type = str

# Aligned comparison operators
assert type(self.node)       is Schema__MGraph__Node
assert self.node.value       == "test_value"
assert len(self.attributes)  == 1
```

### Constructor Calls
```python
node_config = Schema__MGraph__Node__Config(node_id    = Random_Guid(),
                                           value_type = str          )
```

### Imports
```python
from unittest                                                                import TestCase
from mgraph_ai.schemas.Schema__MGraph__Node                                  import Schema__MGraph__Node
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id           import Safe_Id
```

### Documentation Style - NEVER Use Docstrings

**CRITICAL**: In Type_Safe code, NEVER use Python docstrings. All documentation must be inline comments aligned at the end of lines. This maintains the visual pattern recognition that makes Type_Safe code readable.

#### ✗ NEVER DO THIS - Docstrings Break Visual Patterns

```python
# ✗ WRONG - Docstrings clutter the code and break alignment
class Persona__Service(Type_Safe):
    """Core service for persona-based translation and impersonation"""
    
    prompt_builder : Persona__Prompt_Builder
    persona_manager: Persona__Manager
    llm_client     : LLM__Client
    environment    : Enum__Deployment_Environment
    
    def setup(self) -> 'Persona__Service':
        """Initialize the service with configuration"""
        pass
```

#### ✓ ALWAYS DO THIS - Inline Comments with Alignment

```python
# ✓ CORRECT - Clean visual lanes with aligned comments
class Persona__Service(Type_Safe):                              # Core service for persona-based translation and impersonation
    prompt_builder  : Persona__Prompt_Builder                   # Builds prompts for LLM interactions
    persona_manager : Persona__Manager                          # Manages available personas
    llm_client      : LLM__Client                               # Client for LLM API calls
    environment     : Enum__Deployment_Environment              # Current deployment environment
    
    def setup(self) -> 'Persona__Service':                      # Initialize the service with configuration
        self.prompt_builder  = Persona__Prompt_Builder()
        self.persona_manager = Persona__Manager()
        return self
```

## Type_Safe Collection Types

Type_Safe provides type-safe versions of Python's built-in collections:

### Type_Safe__List
```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List import Type_Safe__List

class Schema(Type_Safe):
    items: List[Safe_Str]  # Auto-creates Type_Safe__List

# Direct usage
safe_list = Type_Safe__List(expected_type=Safe_Str)
safe_list.append("test")     # ✓ Auto-converts to Safe_Str
safe_list.append(123)        # ✗ TypeError!
```

### Type_Safe__Dict
```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict import Type_Safe__Dict

class Schema(Type_Safe):
    mapping: Dict[Safe_Id, Safe_Float__Money]  # Type-safe dict

# Direct usage
safe_dict = Type_Safe__Dict(expected_key_type=Safe_Id, 
                            expected_value_type=Safe_Float__Money)
safe_dict["ID-1"] = 99.99   # ✓ Auto-converts both
safe_dict[123] = "invalid"   # ✗ TypeError!
```

### Type_Safe__Set and Type_Safe__Tuple
```python
class Schema(Type_Safe):
    unique_ids : Set[Safe_Id]                    # Type-safe set
    coordinates: Tuple[Safe_Float, Safe_Float]   # Fixed-type tuple
```

## Safe Primitives Reference

### Core Base Classes

All safe primitives inherit from `Type_Safe__Primitive`, which provides:
- Type conversion in `__new__` (validation happens before object creation)
- Arithmetic operators that maintain type safety
- Context manager support (`with` statement)
- Hash/equality that includes type information

### String Types (in osbot_utils.type_safe.primitives.core)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str` | Base safe string class | Very restrictive by default |

Key `Safe_Str` attributes:
- `max_length` (default: 512)
- `regex` - Pattern for invalid chars (default: only alphanumeric)
- `regex_mode` - `REPLACE` or `MATCH` (see below)
- `replacement_char` - Character for replacements (default: '_')
- `allow_empty` - Allow empty strings (default: True)
- `exact_length` - Require exact length match
- `trim_whitespace` - Auto-trim input
- `to_lower_case` - Auto-lowercase
- `strict_validation` - Raise errors vs replace
- `allow_all_replacement_char` - Prevent all-underscore results

#### Regex Modes (Enum__Safe_Str__Regex_Mode)
- **REPLACE**: Regex defines invalid characters to replace (default)
- **MATCH**: Regex defines valid pattern that must match exactly

### Domain String Types (in osbot_utils.type_safe.primitives.domains)

#### Identifiers Domain (domains.identifiers.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__Display_Name` | User-facing names | More permissive than Safe_Id |
| `Safe_Str__Id` | Base identifier class | Alphanumeric + underscore + hyphen |
| `Safe_Str__Key` | Dictionary/config keys | Allows dots for nested keys |
| `Safe_Str__Label` | Hierarchical labels | Allows dots, colons, spaces |
| `Safe_Str__Namespace` | Namespaced identifiers | Dots for namespace separation |
| `Safe_Str__Slug` | URL-friendly strings | Lowercase, hyphens only |
| `Safe_Str__Topic` | Topic names | Allows spaces for readability |

#### Files Domain (domains.files.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__File__Name` | Safe filenames | Prevents path traversal |
| `Safe_Str__File__Path` | File paths | Allows `/` and `\` |

#### Network Domain (domains.network.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__IP_Address` | IP validation | IPv4/IPv6 with ipaddress module |

#### Web Domain (domains.web.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__Url` | URL validation | 2048 char limit |
| `Safe_Str__Email` | Email addresses | Must contain @ |
| `Safe_Str__Username` | Usernames | Alphanumeric + underscore, 32 chars |
| `Safe_Str__Password` | Passwords | Min 8 chars |
| `Safe_Str__API__Parameter` | API param names | Alphanumeric + underscore |

#### HTTP Domain (domains.http.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__Html` | HTML content | 1MB limit, minimal filtering |
| `Safe_Str__Http__Text` | HTTP text content | 1MB limit, wide character support |
| `Safe_Str__Http__Content_Type` | MIME types | `"application/json"` |
| `Safe_Str__Http__ETag` | HTTP ETags | Cache validation |
| `Safe_Str__Http__Last_Modified` | HTTP timestamps | Date formatting |

#### Common Domain (domains.common.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__Text` | General text | 4KB, more chars allowed |
| `Safe_Str__Text__Dangerous` | Risky text | 64KB, very permissive |
| `Safe_Str__Code__Snippet` | Code snippets | 1KB, preserves indentation |
| `Safe_Str__Version` | Version strings | Matches `v1.2.3` pattern exactly |

#### LLM Domain (domains.llm.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__LLM__Prompt` | LLM prompts | 32KB, control chars filtered |
| `Safe_Str__LLM__Message__System` | System prompts | 4KB limit |
| `Safe_Str__LLM__Message__User` | User messages | 32KB full context |
| `Safe_Str__LLM__Message__Assistant` | AI responses | 32KB full context |
| `Safe_Str__LLM__Message__Tool` | Tool responses | 16KB for structured data |
| `Safe_Str__LLM__Model_Id` | Model identifiers | `"gpt-4"`, `"claude-3-opus"` |
| `Safe_Str__LLM__Model_Name` | Display names | `"GPT-4 Turbo"` |
| `Safe_Str__LLM__Model_Slug` | URL-safe slugs | `"gpt-4-turbo"` |
| `Safe_Str__LLM__Description` | Model descriptions | 4KB, rich formatting |
| `Safe_Str__LLM__Modality` | Modality descriptors | `"text->image"` |
| `Safe_Str__LLM__Tokenizer` | Tokenizer types | `"cl100k_base"` |

#### Cryptographic Domain (domains.cryptography.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__Hash` | Hash values | 10-char MD5 subset |
| `Safe_Str__SHA1` | Full SHA1 | 40 hex chars |
| `Safe_Str__SHA1__Short` | Short SHA1 | 7 hex chars |
| `Safe_Str__NaCl__Private_Key` | NaCl private keys | 64 hex chars |
| `Safe_Str__NaCl__Public_Key` | NaCl public keys | 64 hex chars |

#### Git/GitHub Domain (domains.git.safe_str and domains.git.github.safe_str)
| Type | Purpose | Example |
|------|---------|---------|
| `Safe_Str__Git__Branch` | Branch names | `"feature/oauth-login"` |
| `Safe_Str__Git__Tag` | Tag names | `"v1.0.0"` |
| `Safe_Str__Git__Ref` | Any git ref | Branch, tag, or SHA |
| `Safe_Str__GitHub__Repo` | Full repo | `"owner/repo"` |
| `Safe_Str__GitHub__Repo_Owner` | Owner only | `"octocat"` |
| `Safe_Str__GitHub__Repo_Name` | Repo name | `"Hello-World"` |

### Numeric Types

#### Integer Types (in osbot_utils.type_safe.primitives.core)
| Type | Purpose | Range/Features |
|------|---------|----------------|
| `Safe_Int` | Base integer | Range validation, arithmetic ops |
| `Safe_UInt` | Unsigned int | min_value=0 |

`Safe_Int` key attributes:
- `min_value` / `max_value` - Range bounds
- `allow_none` - Allow None input (converts to 0 or min)
- `allow_bool` - Allow bool conversion
- `allow_str` - Allow string parsing
- `strict_type` - No conversions
- `clamp_to_range` - Auto-clamp overflows

#### Float Types (in osbot_utils.type_safe.primitives.core)
| Type | Purpose | Features |
|------|---------|----------|
| `Safe_Float` | Base float | Extensive precision control |

`Safe_Float` key attributes:
- `decimal_places` - Round to N places
- `use_decimal` - Use Decimal internally for exactness
- `epsilon` - Comparison tolerance
- `round_output` - Auto-round results
- `clamp_to_range` - Auto-clamp to min/max
- `allow_inf` / `allow_nan` - Allow special values

#### Domain Numeric Types

**Integer Domains (domains.*.safe_uint)**
| Type | Purpose | Range |
|------|---------|-------|
| `Safe_UInt__Port` | Network ports | 0-65535 |
| `Safe_UInt__Byte` | Single byte | 0-255 |
| `Safe_UInt__Percentage` | Percentage | 0-100 |
| `Safe_UInt__FileSize` | File sizes | With KB/MB/GB methods |
| `Safe_UInt__LLM__Max_Tokens` | Token limits | 1-200000 |

**Float Domains (domains.numerical.safe_float)**
| Type | Purpose | Features |
|------|---------|----------|
| `Safe_Float__Money` | Currency | Decimal arithmetic, 2 places |
| `Safe_Float__Financial` | Finance calcs | Decimal, 2 places |
| `Safe_Float__Percentage_Exact` | Precise % | 0-100, decimal |
| `Safe_Float__Engineering` | Engineering | 6 decimals, epsilon=1e-6 |
| `Safe_Float__Scientific` | Science | 15 decimals, allows inf/nan |

**LLM Float Domains (domains.llm.safe_float)**
| Type | Purpose | Range |
|------|---------|-------|
| `Safe_Float__LLM__Temperature` | Temperature param | 0.0-2.0, 2 decimals |
| `Safe_Float__LLM__Top_P` | Nucleus sampling | 0.0-1.0, 2 decimals |

### Identity Types (domains.identifiers)
```python
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id

class UserId(Safe_Id): pass
class ProductId(Safe_Id): pass

user_id    = UserId("USR-123")
product_id = ProductId("PRD-456")
# user_id != product_id  # Different types!
```

Note: `Safe_Id` is now complemented by `Safe_Str__Id` which provides similar functionality 
but as a Safe_Str subclass with configurable regex patterns. Use `Safe_Id` for legacy 
compatibility or when you need the specific Safe_Id behavior, and `Safe_Str__Id` when 
you want the Safe_Str infrastructure with identifier-specific constraints.

Special identity types:
- `Safe_Id` - Base identifier (letters, numbers, _, -, max 512 chars)
- `Random_Guid` - Auto-generates UUID
- `Random_Guid_Short` - Auto-generates short ID
- `Timestamp_Now` - Auto-captures current timestamp
- `Guid` - UUID5 generation from value

## Enum Support in Type_Safe

Type_Safe now has full support for Python Enums with automatic serialization/deserialization:

```python
from enum import Enum
from osbot_utils.type_safe.Type_Safe import Type_Safe

# Define your enum
class Enum__LLM__Role(str, Enum):
    SYSTEM    = "system"
    USER      = "user"
    ASSISTANT = "assistant"
    TOOL      = "tool"
    
    def __str__(self):
        return self.value  # Override for string representation

# Use in Type_Safe classes
class Schema__LLM__Message(Type_Safe):
    role    : Enum__LLM__Role                           # Enum type annotation
    content : Safe_Str__LLM__Message__User
    
# Automatic conversion from strings
message = Schema__LLM__Message(role="user", content="Hello")
print(message.role)           # Enum__LLM__Role.USER
print(str(message.role))      # "user"

# JSON serialization preserves enum values
json_data = message.json()    # {"role": "user", "content": "Hello"}
restored = Schema__LLM__Message.from_json(json_data)
assert restored.role == Enum__LLM__Role.USER  # Enum restored!

# Runtime validation
message.role = "invalid"      # ValueError: Invalid value 'invalid'
```

### Enum Best Practices

```python
# String-based enums for external APIs
class Enum__API__Status(str, Enum):
    PENDING   = "pending"
    COMPLETED = "completed"
    FAILED    = "failed"

# Integer-based enums for internal use
class Enum__Priority(int, Enum):
    LOW    = 1
    MEDIUM = 2
    HIGH   = 3

# Use when you need methods on enum values
class Enum__File__Type(str, Enum):
    PDF  = "pdf"
    DOCX = "docx"
    TXT  = "txt"
    
    def get_mime_type(self):
        return {
            "pdf" : "application/pdf",
            "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "txt" : "text/plain"
        }[self.value]
```

## Type_Safe Validation Framework

Type_Safe includes a validation framework using `Annotated` types:

```python
from osbot_utils.type_safe.validators.Type_Safe__Validator import Validate
from osbot_utils.type_safe.validators.Validator__Min import Min
from osbot_utils.type_safe.validators.Validator__Max import Max
from osbot_utils.type_safe.validators.Validator__One_Of import One_Of
from osbot_utils.type_safe.validators.Validator__Regex import Regex

class Schema__User(Type_Safe):
    age      : Validate[int, Min(18), Max(100)]                 # 18-100 range
    priority : Validate[str, One_Of(["low", "medium", "high"])] # choices
    code     : Validate[str, Regex(r'^[A-Z]{3}-\d{4}$')]        # Pattern match
```

Available validators:
- `Min(value)` - Minimum value/length
- `Max(value)` - Maximum value/length
- `One_Of(list)` - Must be in list
- `Regex(pattern, description)` - Match regex pattern

## Creating Custom Safe Types

### Domain-Specific Safe_Str Types

Creating custom Safe_Str types is straightforward - usually just requires updating regex and size:

```python
from osbot_utils.type_safe.primitives.core.Safe_Str import Safe_Str
from osbot_utils.type_safe.primitives.core.enums.Enum__Safe_Str__Regex_Mode import Enum__Safe_Str__Regex_Mode
import re

# Username: alphanumeric, underscores, 3-20 chars
class Safe_Str__Username(Safe_Str):
    max_length      = 20
    regex           = re.compile(r'[^a-zA-Z0-9_]')  # Remove unsafe chars
    regex_mode      = Enum__Safe_Str__Regex_Mode.REPLACE
    allow_empty     = False

# Email-like validation
class Safe_Str__Email(Safe_Str):
    max_length         = 255
    regex              = re.compile(r'^[\w\.-]+@[\w\.-]+\.\w+$')
    regex_mode         = Enum__Safe_Str__Regex_Mode.MATCH
    strict_validation  = True

# Database identifier
class Safe_Str__DB_Name(Safe_Str):
    max_length        = 64
    regex             = re.compile(r'[^a-z0-9_]')  # Lowercase, numbers, underscore
    replacement_char  = '_'
    
# API Key format
class Safe_Str__API_Key(Safe_Str):
    max_length         = 32
    regex              = re.compile(r'^[A-Z0-9]{32}$')
    regex_mode         = Enum__Safe_Str__Regex_Mode.MATCH
    strict_validation  = True
    exact_length       = True  # Require exact length match
```

Note: The default Safe_Str is quite restrictive (only letters and numbers), so you'll often need custom versions.

### Domain-Specific Safe_Int Types

```python
from osbot_utils.type_safe.primitives.core.Safe_Int   import Safe_Int
from osbot_utils.type_safe.primitives.core.Safe_UInt import Safe_UInt

# Age with realistic bounds
class Safe_UInt__Age(Safe_UInt):
    min_value  = 0
    max_value  = 150

# Temperature in Celsius
class Safe_Int__Temperature_C(Safe_Int):
    min_value = -273  # Absolute zero
    max_value = 5778  # Surface of the sun

# HTTP Status Code
class Safe_UInt__HTTP_Status(Safe_UInt):
    min_value = 100
    max_value = 599

# Database ID (positive only)
class Safe_UInt__DB_ID(Safe_UInt):
    min_value   = 1      # No zero IDs
    allow_none  = False
```

### Domain-Specific Safe_Float Types

```python
from osbot_utils.type_safe.primitives.core.Safe_Float import Safe_Float

# Scientific measurement with uncertainty
class Safe_Float__Measurement(Safe_Float):
    decimal_places = 4
    epsilon        = 1e-4
    use_decimal    = False  # Performance over exactness
    
# Percentage with bounds
class Safe_Float__Discount(Safe_Float):
    min_value      = 0.0
    max_value      = 100.0
    decimal_places = 2
    clamp_to_range = True  # Auto-clamp to valid range
```

### Using Identifier Safe String Types

```python
from osbot_utils.type_safe.Type_Safe                                                      import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id           import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Display_Name import Safe_Str__Display_Name
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Key          import Safe_Str__Key
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Label        import Safe_Str__Label
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Namespace    import Safe_Str__Namespace
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Slug         import Safe_Str__Slug
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Topic        import Safe_Str__Topic

class Schema__Service_Config(Type_Safe):
    # Use specific identifier types for different purposes
    service_id      : Safe_Str__Id                # "service-123" 
    display_name    : Safe_Str__Display_Name      # "My Service (v2.0)"
    config_key      : Safe_Str__Key               # "database.connection.pool"
    category_label  : Safe_Str__Label             # "infrastructure:database:primary"
    namespace       : Safe_Str__Namespace         # "com.example.services"
    url_slug        : Safe_Str__Slug              # "my-service-v2"
    discussion_topic: Safe_Str__Topic             # "Service Configuration Updates"

# Each type has specific validation rules
config = Schema__Service_Config()
config.service_id       = "SVC_123-abc"          # ✓ Alphanumeric, underscore, hyphen
config.display_name     = "Service (Beta) #1"    # ✓ More permissive characters
config.config_key       = "app.settings.timeout" # ✓ Dots allowed for nesting
config.category_label   = "tier:1:critical"      # ✓ Colons for hierarchy
config.namespace        = "io.company.service"   # ✓ Dots for namespacing
config.url_slug         = "service-beta-1"       # ✓ Lowercase with hyphens
config.discussion_topic = "Beta Testing Phase 1" # ✓ Spaces allowed

# Type safety prevents mixing
config.url_slug = "Service Beta"  # ✗ ValueError - spaces not allowed in slugs
config.service_id = "SVC@123"     # ✗ ValueError - @ not allowed in IDs
```

## Type_Safe Methods Reference

Type_Safe classes come with built-in methods for common operations:

### Data Access Methods
- `__locals__()` - Get instance's attribute values (excludes internals)
- `__kwargs__()` - Get all attributes including inherited defaults
- `__default_kwargs__()` - Get class-level defaults
- `__cls_kwargs__()` - Get class variables and their values
- `__attr_names__()` - Get list of attribute names

### Serialization Methods
- `json()` / `serialize_to_dict()` - Convert to dict
- `json__compress()` - Compressed JSON with type registry
- `from_json(data)` - Deserialize from JSON
- `from_json__compressed(data)` - Deserialize compressed JSON
- `obj()` - Convert to namespace object

### Utility Methods
- `reset()` - Reset all attributes to defaults
- `update_from_kwargs(**kwargs)` - Update multiple attributes
- `print()` - Pretty print the object

## Default Values and Auto-initialization in Type_Safe

Type_Safe automatically initializes attributes based on their types - you rarely need to use `None` or `Optional`. Understanding this auto-initialization behavior is key to writing clean Type_Safe code.

### Why Type_Safe Prohibits Mutable Default Values

**CRITICAL**: Type_Safe prevents you from assigning mutable default values (lists, dicts, objects) directly in class definitions. This is a security feature that prevents one of Python's most dangerous gotchas - shared mutable state across instances:

```python
# ❌ DANGEROUS Python Pattern (Type_Safe prevents this)
class DangerousClass:
    items = []  # This list is SHARED across ALL instances!
    
obj1 = DangerousClass()
obj2 = DangerousClass()
obj1.items.append("secret_data")
print(obj2.items)  # ['secret_data'] - DATA LEAK! 

# ✅ Type_Safe PREVENTS this vulnerability
class SafeClass(Type_Safe):
    items: List[str]  # Each instance gets its OWN list
    
obj1 = SafeClass()
obj2 = SafeClass()
obj1.items.append("secret_data")
print(obj2.items)  # [] - Safe! Each instance is isolated
```

This shared mutable state has caused:
- **Security breaches**: User A seeing User B's data
- **Memory leaks**: Objects never garbage collected
- **Race conditions**: Concurrent modifications to shared state
- **Data corruption**: Unexpected modifications from other instances

### How Type_Safe Auto-initialization Works

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from typing import List, Dict, Set

class Schema__Message(Type_Safe):
    # Safe primitives auto-initialize to their empty/zero values
    content     : Safe_Str                    # Auto-initializes to ''
    count       : Safe_UInt                   # Auto-initializes to 0
    price       : Safe_Float__Money           # Auto-initializes to 0.00
    
    # Collections auto-initialize to empty (NEW instance per object!)
    tags        : List[Safe_Str]              # Auto-initializes to [] (unique instance)
    metadata    : Dict[str, str]              # Auto-initializes to {} (unique instance)
    unique_ids  : Set[Safe_Id]                # Auto-initializes to set() (unique instance)
    
    # Custom Type_Safe classes auto-initialize if possible
    options     : Schema__Options             # Auto-initializes to Schema__Options()
    
    # Use explicit None ONLY when you truly need nullable
    parent_id   : Safe_Id = None              # Explicitly nullable
    expires_at  : Safe_Str__Timestamp = None  # Explicitly nullable

# Usage example
message = Schema__Message()
print(message.content)      # ''  - auto-initialized
print(message.count)        # 0   - auto-initialized  
print(message.tags)         # []  - auto-initialized (unique to this instance)
print(message.options)      # Schema__Options() - auto-initialized
print(message.parent_id)    # None - explicitly set
```

#### Special Auto-initializing Types

Some Type_Safe types have built-in auto-initialization behavior that generates new values on each instantiation. **Never override `__init__` to set these values** - Type_Safe handles this automatically:

```python
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid import Random_Guid
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now import Timestamp_Now

class Schema__Response(Type_Safe):          # These types auto-generate values on instantiation:
    request_id : Random_Guid                # Auto-generates new GUID each time
    timestamp  : Timestamp_Now               # Auto-generates current timestamp
    
    # ✗ NEVER DO THIS - redundant __init__ override!
    # def __init__(self, **kwargs):
    #     super().__init__(**kwargs)
    #     if self.timestamp is None:
    #         self.timestamp = Timestamp_Now()  # Already handled!

# Usage
response1 = Schema__Response()
response2 = Schema__Response()

print(response1.request_id)  # e.g., "a4f3c2b1-..."
print(response2.request_id)  # Different: "b7d9e4a2-..."
print(response1.timestamp)   # e.g., "2024-01-15T10:30:45Z"
print(response2.timestamp)   # Different: "2024-01-15T10:30:46Z"
```

**Auto-initializing types include:**
- `Random_Guid` - Generates unique UUID on each instantiation
- `Random_Guid_Short` - Generates short unique ID
- `Timestamp_Now` - Captures current timestamp on instantiation
- `Obj_Id` - Generates unique object identifier
- Any custom Type_Safe class with default generation logic

**Key principle:** If a type generates its own default value, don't override `__init__` to set it. The whole point of these types is to auto-generate their values!

### Complex Object Auto-initialization During __init__

When Type_Safe classes are used as attributes in other classes, they're automatically instantiated during the parent's `__init__` phase:

```python
class Schema__Config(Type_Safe):
    retry_count : Safe_UInt                   # Auto: 0
    timeout     : Safe_UInt = 30              # Explicit default: 30
    max_retries : Safe_UInt = 3               # Explicit default: 3

class Schema__Database__Config(Type_Safe):
    host        : Safe_Str__Host              # Auto: ''
    port        : Safe_UInt__Port             # Auto: 0 (or could set default)
    ssl_enabled : bool = True                 # Explicit default: True

class Schema__Service(Type_Safe):
    name        : Safe_Str                    # Auto: ''
    config      : Schema__Config              # Auto: NEW Schema__Config() during __init__
    db_config   : Schema__Database__Config    # Auto: NEW Schema__Database__Config() during __init__
    fallback    : Schema__Config = None       # Explicitly nullable - no auto-init

# During instantiation, Type_Safe's __init__ creates new instances
service1 = Schema__Service()
service2 = Schema__Service()

# Each service has its OWN config instances (not shared!)
service1.config.retry_count = 5
service2.config.retry_count = 10

print(service1.config.retry_count)      # 5 - instance 1's value
print(service2.config.retry_count)      # 10 - instance 2's value (not affected!)

# The nested objects are fully initialized with their defaults
print(service1.config.timeout)          # 30 - explicit default preserved
print(service1.config.max_retries)      # 3  - explicit default preserved
print(service1.db_config.ssl_enabled)   # True - nested default preserved
print(service1.db_config.port)          # 0 - auto-initialized

# Nullable fields remain None
print(service1.fallback)                # None - explicitly nullable, not auto-initialized
```

### When to Use None vs Relying on Auto-initialization

```python
class Schema__User(Type_Safe):
    # ✓ GOOD: Let Type_Safe handle defaults
    username    : Safe_Str__Username          # Auto: '' (or min length if required)
    age         : Safe_UInt__Age              # Auto: 0
    tags        : List[Safe_Str]              # Auto: [] (unique list)
    settings    : Schema__User_Settings       # Auto: Schema__User_Settings() (unique instance)
    
    # ✓ GOOD: Explicit None for truly optional fields with semantic meaning
    deleted_at  : Safe_Str__Timestamp = None  # None means "never deleted"
    referrer_id : Safe_Id             = None  # None means "no referrer"
    supervisor  : 'Schema__User'      = None  # None means "no supervisor"
    
    # ✗ AVOID: Using Optional when auto-init would work
    # description : Optional[Safe_Str]        # Just use Safe_Str
    # items      : Optional[List[str]]        # Just use List[str]
```

### Best Practices

1. **Trust auto-initialization** - Most types have sensible defaults
2. **Never assign mutable defaults in class definition** - Type_Safe prevents this footgun
3. **Use explicit `= None` sparingly** - Only when `None` has semantic meaning (e.g., "not set", "deleted", "unlimited")
4. **Avoid `Optional[]` in most cases** - Type_Safe handles this better with auto-init
5. **Document when None matters** - If `None` has special meaning, comment it
6. **Remember each instance is isolated** - No shared state between instances

### Security Benefits Summary

By preventing mutable defaults and auto-initializing unique instances, Type_Safe eliminates:
- **Data leaks** between user sessions
- **State pollution** across requests
- **Memory leaks** from shared references
- **Race conditions** in concurrent code
- **Debugging nightmares** from unexpected shared state

Each Type_Safe instance is a clean, isolated environment with its own state - exactly what secure, maintainable code needs.

## Advanced Topics

### Using Literal for Quick Enums

Type_Safe now supports `Literal` types with runtime enforcement - perfect for quick enums without creating separate Enum classes:

```python
from typing import Literal

class Schema__Open_Router__Message(Type_Safe):
    # Literal enforces these exact values at runtime!
    role    : Literal["assistant", "system", "user", "tool"]  # Only these 4 values allowed
    content : Safe_Str__Message_Content
    tool_id : Safe_Str = None

# Runtime validation works!
message      = Schema__Open_Router__Message()
message.role = "user"       # ✓ Valid
message.role = "admin"      # ✗ ValueError: must be one of ["assistant", "system", "user", "tool"]

class Schema__Provider_Preferences(Type_Safe):
    # Mix Literal with other types
    data_collection : Literal["allow", "deny"]         = "deny"   # Two-state without boolean
    priority        : Literal["low", "medium", "high"] = "medium" # Quick priority levels
    mode            : Literal["dev", "test", "prod"]   = "dev"    # Environment modes
```

Use Literal when:
- You have a small, fixed set of string values
- Creating a full Enum class would be overkill
- Values are unlikely to change or be reused elsewhere

Use a proper Enum when:
- Values are reused across multiple schemas
- You need enum methods or properties
- The set of values might grow significantly

### Schema Files Best Practice

**CRITICAL: Schema files should ONLY contain schema definitions - NO business logic!**

```python
# ✓ CORRECT - Pure schema definition
class Schema__Order(Type_Safe):
    id       : Safe_Str__OrderId
    customer : Safe_Str__CustomerId
    items    : List[Schema__Order__Item]
    total    : Safe_Float__Money
    status   : Safe_Str__Status

# ✗ WRONG - Schema with business logic
class Schema__Order(Type_Safe):
    id       : Safe_Str__OrderId
    customer : Safe_Str__CustomerId
    items    : List[Schema__Order__Item]
    total    : Safe_Float__Money
    status   : Safe_Str__Status
    
    def calculate_tax(self):  # NO! Business logic doesn't belong here
        return self.total * 0.08
        
    def validate_order(self):  # NO! Validation logic goes elsewhere
        if self.total < 0:
            raise ValueError("Invalid total")
```

Exceptions are rare and usually involve overriding Type_Safe methods for special cases:
```python
# RARE EXCEPTION - Only when absolutely necessary
class Schema__Special(Type_Safe):
    value: Safe_Str
    
    def __setattr__(self, name, value):        
        if name == 'value' and value == 'special_case':             # Only override Type_Safe internals when absolutely required
            value = transform_special(value)
        super().__setattr__(name, value)
```

### Runtime Type Checking & Round-Trip Serialization

Type_Safe provides **continuous runtime type checking** - not just at creation or assignment, but for EVERY operation including collection manipulations. This is unique compared to frameworks like Pydantic which only validate at boundaries.

#### Continuous Runtime Protection

```python
class DataStore(Type_Safe):
    items  : List[Safe_Str__ProductId]
    prices : Dict[Safe_Str__ProductId, Safe_Float__Money]

store = DataStore()

# EVERY operation is type-checked at runtime:
store.items.append(Safe_Str__ProductId("PROD-123"))  # ✓ Valid
store.items.append("raw-string")                     # ✗ TypeError immediately!
store.items[0] = None                                # ✗ TypeError immediately!

store.prices["PROD-123"] = Safe_Float__Money(19.99)  # ✓ Valid  
store.prices["PROD-456"] = 19.99                     # ✓ Auto-converted
store.prices["PROD-789"] = "not-a-number"            # ✗ TypeError immediately!
```

#### Perfect Round-Trip Serialization

```python
# Complex nested structure
class Order(Type_Safe):
    id       : Safe_Str__OrderId
    customer : Safe_Str__CustomerId  
    items    : Dict[Safe_Str__ProductId, Safe_UInt]
    total    : Safe_Float__Money
    status   : Enum__Order_Status  # Enums serialize/deserialize perfectly

# Create and populate
order = Order(id       = "ORD-2024-001"          ,
              customer = "CUST-123"              , 
              items    = {"PROD-A": 2, "PROD-B": 1},
              total    = 299.99                  ,
              status   = "pending"               )  # String auto-converts to enum

# Serialize to JSON
json_data = order.json()

# Send over network, save to DB, etc.
send_to_api(json_data)

# Reconstruct with FULL type safety preserved
new_order = Order.from_json(json_data)
assert isinstance(new_order.id, Safe_Str__OrderId)         # Type preserved!
assert isinstance(new_order.total, Safe_Float__Money)      # Exact decimal!
assert new_order.status == Enum__Order_Status.PENDING      # Enum restored!
assert new_order.items["PROD-A"] == 2                      # Data intact!
```

### Performance & Caching

Type_Safe includes a sophisticated caching system to optimize performance:

```python
from osbot_utils.type_safe.type_safe_core.shared.Type_Safe__Cache import type_safe_cache

# The cache uses WeakKeyDictionary for automatic cleanup
# Caches include:
# - Class annotations
# - Method Resolution Order (MRO)
# - Type origins (get_origin results)
# - Immutable variable lists
# - Class kwargs

# View cache statistics (for debugging)
type_safe_cache.print_cache_hits()
```

Key performance features:
- **Automatic caching** of class metadata
- **WeakKeyDictionary** prevents memory leaks
- **@type_safe optimization** - methods with no params have ~5x overhead vs 250x
- **Immutable types cached** - no repeated validation

### FastAPI Integration - No Pydantic Needed!

With OSBot_Fast_API's built-in Type_Safe support, **you should NOT use Pydantic models**. Type_Safe classes work directly in FastAPI routes with automatic conversion:

```python
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes

# Define your Type_Safe models (NOT Pydantic!)
class UserRequest(Type_Safe):
    username : Safe_Str__Username
    email    : Safe_Str__Email
    age      : Safe_UInt__Age
    role     : Enum__User_Role  # Enums work in FastAPI!

class UserResponse(Type_Safe):
    id         : Safe_Str__UserId
    username   : Safe_Str__Username
    created_at : Safe_Str__Timestamp
    role       : Enum__User_Role
    
class Routes_Users(Fast_API__Routes):                                   # Use directly in routes - automatic conversion happens!
    tag = 'users'
    
    def create_user(self, request: UserRequest) -> UserResponse:        # request is Type_Safe with full validation
        # No manual conversion needed!
        user_id = self.user_service.create(request)
        
        return UserResponse(id         = user_id              ,
                            username   = request.username     ,
                            created_at = timestamp_now()      ,
                            role       = request.role         )  # Enum passes through
    
    def get_user(self, user_id: Safe_Str__UserId) -> UserResponse:      # Even path parameters can use Safe types!
        return self.user_service.get(user_id)
    
    def setup_routes(self):
        self.add_route_post(self.create_user)
        self.add_route_get(self.get_user)

# FastAPI automatically:
# 1. Converts incoming JSON to Type_Safe objects
# 2. Validates all constraints
# 3. Converts Type_Safe responses back to JSON
# 4. Generates OpenAPI schema from Type_Safe classes
# 5. Handles Enum serialization/deserialization
```

#### Why NOT Pydantic with FastAPI?

```python
# ✗ DON'T use Pydantic models anymore
from pydantic import BaseModel

class UserModel(BaseModel):  # Unnecessary!
    username: str             # No sanitization
    age: int                  # No bounds checking

# ✓ DO use Type_Safe directly
class User(Type_Safe):
    username : Safe_Str__Username  # Sanitized
    age      : Safe_UInt__Age      # Bounded
```

Benefits of Type_Safe over Pydantic in FastAPI:
- **Continuous validation** throughout request lifecycle
- **Automatic sanitization** of inputs
- **Domain type safety** (UserID ≠ ProductID)
- **No duplicate model definitions** (one model for all layers)
- **Built-in security** via Safe primitives

## Complete Example

```python
from osbot_utils.type_safe.Type_Safe                                                    import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id                      import Safe_Id
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Money   import Safe_Float__Money
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url               import Safe_Str__Url
from typing                                                                            import List, Dict, Literal
from enum                                                                               import Enum

# Domain IDs
class UserId(Safe_Id): pass
class OrderId(Safe_Id): pass
class ProductId(Safe_Id): pass

# Order status enum
class Enum__Order_Status(str, Enum):
    PENDING   = "pending"
    CONFIRMED = "confirmed"  
    SHIPPED   = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

class Order(Type_Safe):
    id         : OrderId
    user_id    : UserId
    items      : Dict[ProductId, int]
    subtotal   : Safe_Float__Money
    tax        : Safe_Float__Money
    status     : Enum__Order_Status     = Enum__Order_Status.PENDING
    priority   : Literal["low", "normal", "high"] = "normal"  # Literal type
    tracking   : Safe_Str__Url          = None
    
    def total(self) -> Safe_Float__Money:                     # Calculate total
        return self.subtotal + self.tax

# Usage
order = Order(id       = OrderId("ORD-001")        ,
              user_id  = UserId("USR-123")         ,
              items    = {ProductId("P1"): 2}      ,
              subtotal = Safe_Float__Money(99.99)  ,
              tax      = Safe_Float__Money(9.99)   ,
              status   = "confirmed"                )  # String auto-converts to enum

# Type safety
order.user_id = OrderId("ORD-999")  # ValueError! Wrong type
order.priority = "urgent"           # ValueError! Not in Literal values

# Serialization preserves everything
json_data = order.json()
new_order = Order.from_json(json_data)  # Types, enums, literals all preserved
assert new_order.status == Enum__Order_Status.CONFIRMED
```

## Critical Anti-Patterns to Avoid

```python
# ✗ DON'T: Mutable defaults
class Bad(Type_Safe):
    items: List[str] = []      # ERROR

# ✗ DON'T: Missing annotations  
class Bad(Type_Safe):
    name = "default"           # Missing type

# ✗ DON'T: Untyped collections
class Bad(Type_Safe):
    data: dict                 # Should be Dict[K, V]

# ✗ DON'T: Forward ref other classes
class Node(Type_Safe):
    other: 'SomeOtherClass'    # Won't work

# ✗ DON'T: Raw primitives when Safe types exist
class Bad(Type_Safe):
    prompt: str                # Should be Safe_Str__LLM__Prompt
    port: int                  # Should be Safe_UInt__Port
```

## Serialization

```python
# From/to JSON
user      = User.from_json('{"name": "Alice", "age": 30}')
json_data = user.json()  # Returns dict

# Nested objects work automatically
company = Company.from_json({
    "name"         : "TechCorp",
    "headquarters" : {
        "street" : "123 Main",
        "city"   : "Boston"
    }
})

# Compressed JSON (with type registry)
compressed = user.json__compress()  # Optimized JSON with type registry
restored   = User.from_json__compressed(compressed)
```

## Import Reference

```python
# Core
from osbot_utils.type_safe.Type_Safe                                                           import Type_Safe
from osbot_utils.type_safe.Type_Safe__Base                                                     import Type_Safe__Base
from osbot_utils.type_safe.Type_Safe__Primitive                                                import Type_Safe__Primitive
from osbot_utils.type_safe.decorators.type_safe                                                import type_safe

# Core Primitives
from osbot_utils.type_safe.primitives.core.Safe_Str                                            import Safe_Str
from osbot_utils.type_safe.primitives.core.Safe_Int                                             import Safe_Int
from osbot_utils.type_safe.primitives.core.Safe_UInt                                            import Safe_UInt
from osbot_utils.type_safe.primitives.core.Safe_Float                                           import Safe_Float
from osbot_utils.type_safe.primitives.core.enums.Enum__Safe_Str__Regex_Mode                     import Enum__Safe_Str__Regex_Mode

# Collections
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List                           import Type_Safe__List
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict                           import Type_Safe__Dict
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Set                            import Type_Safe__Set
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Tuple                          import Type_Safe__Tuple

# Validators
from osbot_utils.type_safe.validators.Type_Safe__Validator                                      import Validate
from osbot_utils.type_safe.validators.Validator__Min                                            import Min
from osbot_utils.type_safe.validators.Validator__Max                                            import Max
from osbot_utils.type_safe.validators.Validator__One_Of                                         import One_Of
from osbot_utils.type_safe.validators.Validator__Regex                                          import Regex

# Domain: Common
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text                    import Safe_Str__Text
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text__Dangerous         import Safe_Str__Text__Dangerous
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Code__Snippet           import Safe_Str__Code__Snippet
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version                 import Safe_Str__Version
from osbot_utils.type_safe.primitives.domains.common.safe_uint.Safe_UInt__Byte                  import Safe_UInt__Byte

# Domain: Files
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Name               import Safe_Str__File__Name
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path               import Safe_Str__File__Path
from osbot_utils.type_safe.primitives.domains.files.safe_uint.Safe_UInt__FileSize               import Safe_UInt__FileSize

# Domain: Network
from osbot_utils.type_safe.primitives.domains.network.safe_str.Safe_Str__IP_Address             import Safe_Str__IP_Address
from osbot_utils.type_safe.primitives.domains.network.safe_uint.Safe_UInt__Port                 import Safe_UInt__Port

# Domain: Web
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url                        import Safe_Str__Url
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Email                      import Safe_Str__Email
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Username                   import Safe_Str__Username
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Password                   import Safe_Str__Password
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__API__Parameter             import Safe_Str__API__Parameter

# Domain: HTTP
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Html                      import Safe_Str__Html
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Http__Text                import Safe_Str__Http__Text
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Http__Content_Type        import Safe_Str__Http__Content_Type
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Http__ETag                import Safe_Str__Http__ETag
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Http__Last_Modified       import Safe_Str__Http__Last_Modified

# Domain: LLM
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Prompt                import Safe_Str__LLM__Prompt
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Message__System       import Safe_Str__LLM__Message__System
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Message__User         import Safe_Str__LLM__Message__User
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Message__Assistant    import Safe_Str__LLM__Message__Assistant
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Message__Tool         import Safe_Str__LLM__Message__Tool
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Model_Id              import Safe_Str__LLM__Model_Id
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Model_Name            import Safe_Str__LLM__Model_Name
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Model_Slug            import Safe_Str__LLM__Model_Slug
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Description           import Safe_Str__LLM__Description
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Modality              import Safe_Str__LLM__Modality
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Tokenizer             import Safe_Str__LLM__Tokenizer
from osbot_utils.type_safe.primitives.domains.llm.safe_float.Safe_Float__LLM__Temperature       import Safe_Float__LLM__Temperature
from osbot_utils.type_safe.primitives.domains.llm.safe_float.Safe_Float__LLM__Top_P             import Safe_Float__LLM__Top_P
from osbot_utils.type_safe.primitives.domains.llm.safe_uint.Safe_UInt__LLM__Max_Tokens          import Safe_UInt__LLM__Max_Tokens
from osbot_utils.type_safe.primitives.domains.llm.enums.Enum__LLM__Role                         import Enum__LLM__Role

# Domain: Cryptography
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash              import Safe_Str__Hash
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__SHA1              import Safe_Str__SHA1
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__SHA1__Short       import Safe_Str__SHA1__Short
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__NaCl__Private_Key import Safe_Str__NaCl__Private_Key
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__NaCl__Public_Key  import Safe_Str__NaCl__Public_Key

# Domain: Git/GitHub
from osbot_utils.type_safe.primitives.domains.git.safe_str.Safe_Str__Git__Branch                import Safe_Str__Git__Branch
from osbot_utils.type_safe.primitives.domains.git.safe_str.Safe_Str__Git__Tag                   import Safe_Str__Git__Tag
from osbot_utils.type_safe.primitives.domains.git.safe_str.Safe_Str__Git__Ref                   import Safe_Str__Git__Ref
from osbot_utils.type_safe.primitives.domains.git.github.safe_str.Safe_Str__GitHub__Repo        import Safe_Str__GitHub__Repo
from osbot_utils.type_safe.primitives.domains.git.github.safe_str.Safe_Str__GitHub__Repo_Owner  import Safe_Str__GitHub__Repo_Owner
from osbot_utils.type_safe.primitives.domains.git.github.safe_str.Safe_Str__GitHub__Repo_Name   import Safe_Str__GitHub__Repo_Name

# Domain: Numerical
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Money            import Safe_Float__Money
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Financial        import Safe_Float__Financial
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Percentage_Exact import Safe_Float__Percentage_Exact
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Engineering      import Safe_Float__Engineering
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Scientific       import Safe_Float__Scientific
from osbot_utils.type_safe.primitives.domains.numerical.safe_uint.Safe_UInt__Percentage         import Safe_UInt__Percentage

# Identifiers
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id                               import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid                           import Random_Guid
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid_Short                     import Random_Guid_Short
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now                         import Timestamp_Now
from osbot_utils.type_safe.primitives.domains.identifiers.Guid                                  import Guid

# Identifiers - Safe String Types
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Display_Name      import Safe_Str__Display_Name
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id                import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Key               import Safe_Str__Key
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Label             import Safe_Str__Label
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Namespace         import Safe_Str__Namespace
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Slug              import Safe_Str__Slug
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Topic             import Safe_Str__Topic
```

## Key Benefits

1. **Runtime Type Safety**: Catches type errors at assignment, not deep in execution
2. **Auto-initialization**: Lists, dicts, sets initialize automatically
3. **Domain Modeling**: Safe_Id prevents mixing incompatible ID types
4. **Perfect Serialization**: JSON round-trips preserve all type information including Enums
5. **Visual Code Structure**: Alignment patterns make bugs obvious
6. **Built-in Security**: Safe types prevent injection attacks and overflow bugs
7. **Performance Optimization**: Sophisticated caching and method optimization
8. **Continuous Validation**: Every operation is type-checked, not just boundaries

## Summary Checklist

When generating Type_Safe code:
- [ ] Inherit from Type_Safe
- [ ] Add type annotations for ALL attributes  
- [ ] Use only immutable defaults (or none)
- [ ] Use specific generic types (List[T], not list)
- [ ] Forward references only to current class
- [ ] Add @type_safe to validated methods
- [ ] Use Safe_* types for domain concepts
- [ ] Follow vertical alignment formatting rules
- [ ] Ban raw primitives - use domain-specific Safe types
- [ ] Keep schemas pure - no business logic
- [ ] Use Enums for fixed sets of values
- [ ] Use Literal for small inline enums
- [ ] Leverage domain-specific Safe types (LLM, Git, crypto, etc.)
- [ ] Use validators with Annotated/Validate for constraints
- [ ] Trust auto-initialization for collections and nested objects
- [ ] Remember Type_Safe__Primitive for custom safe types