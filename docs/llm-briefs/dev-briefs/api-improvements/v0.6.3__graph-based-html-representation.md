# Technical Brief: Graph-Based HTML Representation

## üìã Document Overview

**Project**: MGraph-AI__Service__Html   
**Version**: v0.6.3  
**Date**: 2025-10-18  
**Purpose**: Add graph-based representation of HTML as nodes and edges  
**Implementation Approach**: Additive - new endpoints and schemas, extends BRIEF-001  
**Target Audience**: LLM implementing these changes in a separate session  
**Prerequisites**: BRIEF-001 must be implemented first

---

## üéØ Objectives

### Primary Goal
Transform the HTML service from a "text extraction tool" into an **"HTML Semantic Graph Database"** that represents entire HTML documents as queryable graph structures with typed nodes and relationships.

### Success Criteria
‚úÖ HTML documents represented as typed nodes (Element, Text, Attribute, Script, Style)  
‚úÖ Relationships captured as typed edges (CONTAINS, HAS_CHILD, HAS_ATTRIBUTE, etc.)  
‚úÖ Position-based element hashing for stable identifiers  
‚úÖ Support for querying and traversing the graph  
‚úÖ Compatible with hash replacement workflow from BRIEF-001  
‚úÖ Extensible for future node types (JSON, JavaScript extraction)  

---

## üåü Vision & Context

### Why Graph Representation?

**Current State**: The service returns flat lists or nested dicts  
**Future State**: The service returns a queryable graph database of HTML semantics

**Key Insights:**
1. **HTML IS a graph** - Elements, text, attributes form a directed graph
2. **MGraph-AI** - The "M" stands for graph/network representation
3. **Advanced Queries** - "Find all text in buttons", "Show attribute values", "Track parent chains"
4. **Semantic Understanding** - Relationships are first-class entities
5. **Future-Proof** - Easy to add JavaScript/JSON/CSS nodes later

### Graph Architecture Philosophy

**Nodes = Entities** (things that exist)
- Element nodes: `<div>`, `<p>`, `<span>`
- Text nodes: "Hello World"
- Attribute nodes: `class="container"`
- Script nodes: `<script>...</script>`
- Style nodes: `<style>...</style>`

**Edges = Relationships** (how things connect)
- HAS_CHILD: `<div>` ‚Üí `<p>` (parent-child)
- CONTAINS: `<p>` ‚Üí "text" (element contains text)
- HAS_ATTRIBUTE: `<div>` ‚Üí `class="x"` (element has attribute)
- NEXT_SIBLING: `<p>` ‚Üí `<span>` (document order)

---

## üìä Graph Schema Design

### Node Type Hierarchy

```
Schema__Graph__Node__Base (abstract base)
‚îú‚îÄ‚îÄ Schema__Graph__Node__Element (HTML tags)
‚îú‚îÄ‚îÄ Schema__Graph__Node__Text (text content)
‚îú‚îÄ‚îÄ Schema__Graph__Node__Attribute (HTML attributes)
‚îú‚îÄ‚îÄ Schema__Graph__Node__Script (script tags)
‚îú‚îÄ‚îÄ Schema__Graph__Node__Style (style tags/links)
‚îî‚îÄ‚îÄ Schema__Graph__Node__Comment (HTML comments)
```

### Edge Type System

```
Schema__Graph__Edge
‚îú‚îÄ‚îÄ edge_type: HAS_CHILD (element ‚Üí element)
‚îú‚îÄ‚îÄ edge_type: CONTAINS (element ‚Üí text)
‚îú‚îÄ‚îÄ edge_type: HAS_ATTRIBUTE (element ‚Üí attribute)
‚îú‚îÄ‚îÄ edge_type: NEXT_SIBLING (node ‚Üí node)
‚îú‚îÄ‚îÄ edge_type: PREV_SIBLING (node ‚Üí node)
‚îú‚îÄ‚îÄ edge_type: HAS_SCRIPT (element ‚Üí script)
‚îî‚îÄ‚îÄ edge_type: HAS_STYLE (element ‚Üí style)
```

---

## üóÇÔ∏è Complete Schema Definitions

### Base Node Schema

```python
"""
Base schema for all graph nodes
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Node__Base.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                               import Safe_UInt
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str


class Schema__Graph__Node__Base(Type_Safe):
    """Base class for all graph node types"""
    
    # Core identity
    node_id   : Safe_Str__Hash  # Unique node identifier
    node_type : Safe_Str        # "element" | "text" | "attribute" | "script" | "style" | "comment"
    
    # Position in tree
    depth     : Safe_UInt       # Depth in HTML tree (0 = root)
    path      : Safe_Str        # Structural path: "html[0]/body[1]/p[0]"
```

---

### Element Node Schema

```python
"""
Element node - represents HTML tags
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Node__Element.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                               import Safe_UInt
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Base import Schema__Graph__Node__Base


class Schema__Graph__Node__Element(Schema__Graph__Node__Base):
    """Represents an HTML element/tag"""
    
    node_type     : Safe_Str = "element"
    
    # Element-specific fields
    tag           : Safe_Str        # Tag name: "div", "p", "span", "button", etc.
    sibling_index : Safe_UInt       # Position among siblings in parent's children array
    
    # Note: node_id is computed from position in tree (structural hash)
    # Format: "elem_" + md5(path)[:10]
    # Example: "elem_a1b2c3d4e5" for path "html[0]/body[1]/div[2]"
```

---

### Text Node Schema

```python
"""
Text node - represents text content
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Node__Text.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Base import Schema__Graph__Node__Base
from typing                                                                         import Optional


class Schema__Graph__Node__Text(Schema__Graph__Node__Base):
    """Represents text content within HTML"""
    
    node_type     : Safe_Str = "text"
    
    # Text-specific fields
    text          : str                          # Actual text content (or hash if in hash mode)
    is_hash       : bool = False                 # True if text field contains hash instead of content
    original_text : Optional[str] = None         # Original text (only if is_hash=True)
    parent_id     : Safe_Str__Hash               # Element that contains this text
    
    # Note: node_id is computed from content (content hash)
    # Format: "text_" + md5(text)[:10]
    # Example: "text_abc123def0" for text "Hello World"
```

---

### Attribute Node Schema

```python
"""
Attribute node - represents HTML element attributes
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Node__Attribute.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Base import Schema__Graph__Node__Base


class Schema__Graph__Node__Attribute(Schema__Graph__Node__Base):
    """Represents an HTML element attribute"""
    
    node_type       : Safe_Str = "attribute"
    
    # Attribute-specific fields
    attribute_name  : Safe_Str      # "class", "id", "href", "src", "title", etc.
    attribute_value : str           # Value of the attribute
    element_id      : Safe_Str__Hash  # Element that owns this attribute
    
    # Note: node_id is computed from element_id + attribute_name + value
    # Format: "attr_" + md5(element_id + name + value)[:10]
    # Example: "attr_xyz789pqr0" for div's class="container"
```

---

### Script Node Schema

```python
"""
Script node - represents script tags
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Node__Script.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Base import Schema__Graph__Node__Base
from typing                                                                         import Optional


class Schema__Graph__Node__Script(Schema__Graph__Node__Base):
    """Represents a script element"""
    
    node_type     : Safe_Str = "script"
    
    # Script-specific fields
    script_type   : Safe_Str                     # "inline" | "external"
    content       : Optional[str] = None         # Script content (if inline)
    src           : Optional[Safe_Str] = None    # External script URL (if external)
    parent_id     : Safe_Str__Hash               # Element containing this script (usually <head> or <body>)
    
    # Note: node_id is position-based like elements
    # Format: "script_" + md5(path)[:10]
```

---

### Style Node Schema

```python
"""
Style node - represents style tags and link[rel=stylesheet]
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Node__Style.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Base import Schema__Graph__Node__Base
from typing                                                                         import Optional


class Schema__Graph__Node__Style(Schema__Graph__Node__Base):
    """Represents style elements or stylesheets"""
    
    node_type     : Safe_Str = "style"
    
    # Style-specific fields
    style_type    : Safe_Str                     # "inline" | "external" | "attribute"
    content       : Optional[str] = None         # CSS content (if inline)
    href          : Optional[Safe_Str] = None    # External stylesheet URL (if external)
    parent_id     : Safe_Str__Hash               # Element containing this style
    
    # Note: node_id is position-based
    # Format: "style_" + md5(path)[:10]
```

---

### Comment Node Schema

```python
"""
Comment node - represents HTML comments
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Node__Comment.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Base import Schema__Graph__Node__Base


class Schema__Graph__Node__Comment(Schema__Graph__Node__Base):
    """Represents an HTML comment"""
    
    node_type     : Safe_Str = "comment"
    
    # Comment-specific fields
    content       : str                # Comment text
    parent_id     : Safe_Str__Hash     # Element containing this comment
    
    # Note: node_id is position-based
    # Format: "comment_" + md5(path)[:10]
```

---

### Edge Schema

```python
"""
Edge schema - represents relationships between nodes
Location: mgraph_ai_service_html/html__fast_api/schemas/graph/Schema__Graph__Edge.py
"""
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_Str                                import Safe_Str
from typing                                                                         import Optional, Dict


class Schema__Graph__Edge(Type_Safe):
    """Represents a relationship between two nodes"""
    
    # Core identity
    edge_id     : Safe_Str__Hash    # Unique edge identifier
    edge_type   : Safe_Str          # Type of relationship
    
    # Connection
    source_id   : Safe_Str__Hash    # From node
    target_id   : Safe_Str__Hash    # To node
    
    # Optional metadata
    properties  : Optional[Dict] = None  # Additional edge properties


# Edge type constants
EDGE_TYPE_HAS_CHILD      = "HAS_CHILD"       # Element ‚Üí Element (parent-child)
EDGE_TYPE_CONTAINS       = "CONTAINS"        # Element ‚Üí Text (element contains text)
EDGE_TYPE_HAS_ATTRIBUTE  = "HAS_ATTRIBUTE"   # Element ‚Üí Attribute
EDGE_TYPE_NEXT_SIBLING   = "NEXT_SIBLING"    # Node ‚Üí Node (document order)
EDGE_TYPE_PREV_SIBLING   = "PREV_SIBLING"    # Node ‚Üí Node
EDGE_TYPE_HAS_SCRIPT     = "HAS_SCRIPT"      # Element ‚Üí Script
EDGE_TYPE_HAS_STYLE      = "HAS_STYLE"       # Element ‚Üí Style
EDGE_TYPE_HAS_COMMENT    = "HAS_COMMENT"     # Element ‚Üí Comment
```

---

## üîå New Endpoints

### Endpoint 1: `/html/to__graph` - Full Graph Representation

**Purpose**: Convert HTML to complete graph structure with all nodes and edges

**Request Schema**: `Schema__Html__To__Graph__Request`
```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt
from osbot_utils.type_safe.primitives.core.Safe_Bool                       import Safe_Bool
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html


class Schema__Html__To__Graph__Request(Type_Safe):
    """Convert HTML to graph representation"""
    
    html                : Safe_Str__Html
    max_depth           : Safe_UInt = 256
    include_attributes  : Safe_Bool = True   # Include attribute nodes?
    include_scripts     : Safe_Bool = True   # Include script nodes?
    include_styles      : Safe_Bool = True   # Include style nodes?
    include_comments    : Safe_Bool = False  # Include comment nodes?
```

**Response Schema**: `Schema__Html__To__Graph__Response`
```python
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                               import Safe_UInt
from typing                                                                         import List, Dict, Union
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Element   import Schema__Graph__Node__Element
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Text      import Schema__Graph__Node__Text
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Attribute import Schema__Graph__Node__Attribute
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Script    import Schema__Graph__Node__Script
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Style     import Schema__Graph__Node__Style
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Comment   import Schema__Graph__Node__Comment
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Edge            import Schema__Graph__Edge


class Schema__Html__To__Graph__Response(Type_Safe):
    """Complete graph representation of HTML"""
    
    # Core graph data
    nodes : List[Union[
        Schema__Graph__Node__Element,
        Schema__Graph__Node__Text,
        Schema__Graph__Node__Attribute,
        Schema__Graph__Node__Script,
        Schema__Graph__Node__Style,
        Schema__Graph__Node__Comment
    ]]
    
    edges : List[Schema__Graph__Edge]
    
    # Lookup maps for efficient queries
    nodes_by_id         : Dict[Safe_Str__Hash, Dict]                           # node_id ‚Üí node
    nodes_by_type       : Dict[str, List[Safe_Str__Hash]]                      # node_type ‚Üí [node_ids]
    elements_by_tag     : Dict[str, List[Safe_Str__Hash]]                      # tag ‚Üí [element_ids]
    element_to_children : Dict[Safe_Str__Hash, List[Safe_Str__Hash]]           # element_id ‚Üí [child_ids]
    element_to_text     : Dict[Safe_Str__Hash, List[Safe_Str__Hash]]           # element_id ‚Üí [text_ids]
    element_to_attrs    : Dict[Safe_Str__Hash, List[Safe_Str__Hash]]           # element_id ‚Üí [attr_ids]
    text_to_element     : Dict[Safe_Str__Hash, Safe_Str__Hash]                 # text_id ‚Üí parent_element_id
    
    # Metrics
    total_nodes         : Safe_UInt
    total_edges         : Safe_UInt
    total_elements      : Safe_UInt
    total_text_nodes    : Safe_UInt
    total_attributes    : Safe_UInt
    max_depth           : Safe_UInt
```

**Implementation Location**: `Routes__Html.to__graph()`

---

### Endpoint 2: `/html/to__graph__with__text__hashes` - Graph + Hash Workflow

**Purpose**: Combine graph representation with hash replacement workflow

**Request Schema**: `Schema__Html__To__Graph__With__Text__Hashes__Request`
```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt
from osbot_utils.type_safe.primitives.core.Safe_Bool                       import Safe_Bool
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html


class Schema__Html__To__Graph__With__Text__Hashes__Request(Type_Safe):
    """Convert HTML to graph with text replaced by hashes"""
    
    html                : Safe_Str__Html
    max_depth           : Safe_UInt = 256
    include_attributes  : Safe_Bool = True
    include_scripts     : Safe_Bool = True
    include_styles      : Safe_Bool = True
    include_comments    : Safe_Bool = False
```

**Response Schema**: `Schema__Html__To__Graph__With__Text__Hashes__Response`
```python
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                               import Safe_UInt
from typing                                                                         import List, Dict, Union
# ... (same node/edge imports as above)


class Schema__Html__To__Graph__With__Text__Hashes__Response(Type_Safe):
    """Graph with text nodes containing hashes + mapping"""
    
    # Core graph data (text nodes have is_hash=True)
    nodes : List[Union[
        Schema__Graph__Node__Element,
        Schema__Graph__Node__Text,  # ‚Üê text field contains hash, original_text has content
        Schema__Graph__Node__Attribute,
        Schema__Graph__Node__Script,
        Schema__Graph__Node__Style,
        Schema__Graph__Node__Comment
    ]]
    
    edges : List[Schema__Graph__Edge]
    
    # Hash workflow data
    html_dict           : Dict                              # html_dict with text as hashes
    text_hashes_mapping : Dict[Safe_Str__Hash, str]         # {hash: original_text}
    
    # Lookup maps (same as above)
    nodes_by_id         : Dict[Safe_Str__Hash, Dict]
    nodes_by_type       : Dict[str, List[Safe_Str__Hash]]
    elements_by_tag     : Dict[str, List[Safe_Str__Hash]]
    element_to_children : Dict[Safe_Str__Hash, List[Safe_Str__Hash]]
    element_to_text     : Dict[Safe_Str__Hash, List[Safe_Str__Hash]]
    element_to_attrs    : Dict[Safe_Str__Hash, List[Safe_Str__Hash]]
    text_to_element     : Dict[Safe_Str__Hash, Safe_Str__Hash]
    
    # Metrics
    total_nodes         : Safe_UInt
    total_edges         : Safe_UInt
    total_elements      : Safe_UInt
    total_text_nodes    : Safe_UInt
    total_attributes    : Safe_UInt
    max_depth           : Safe_UInt
```

**Implementation Location**: `Routes__Html.to__graph__with__text__hashes()`

---

## üî® Core Implementation: Graph Builder

### New Core Class: `Html__To__Graph`

**Location**: `mgraph_ai_service_html/html__fast_api/core/Html__To__Graph.py`

```python
"""
Core graph builder - converts html_dict to graph structure
"""
from osbot_utils.type_safe.Type_Safe                                                    import Type_Safe
from osbot_utils.utils.Misc                                                             import str_md5
from typing                                                                             import Dict, List, Union, Tuple
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Element   import Schema__Graph__Node__Element
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Text      import Schema__Graph__Node__Text
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Attribute import Schema__Graph__Node__Attribute
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Script    import Schema__Graph__Node__Script
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Style     import Schema__Graph__Node__Style
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Node__Comment   import Schema__Graph__Node__Comment
from mgraph_ai_service_html.html__fast_api.schemas.graph.Schema__Graph__Edge            import (
    Schema__Graph__Edge,
    EDGE_TYPE_HAS_CHILD,
    EDGE_TYPE_CONTAINS,
    EDGE_TYPE_HAS_ATTRIBUTE,
    EDGE_TYPE_NEXT_SIBLING,
    EDGE_TYPE_PREV_SIBLING,
    EDGE_TYPE_HAS_SCRIPT,
    EDGE_TYPE_HAS_STYLE,
    EDGE_TYPE_HAS_COMMENT
)


class Html__To__Graph(Type_Safe):
    """Convert html_dict to graph structure with nodes and edges"""
    
    html_dict           : Dict = None
    include_attributes  : bool = True
    include_scripts     : bool = True
    include_styles      : bool = True
    include_comments    : bool = False
    
    # Collections
    nodes               : List = None
    edges               : List = None
    
    # Lookup maps
    nodes_by_id         : Dict = None
    element_to_children : Dict = None
    element_to_text     : Dict = None
    previous_sibling    : Dict = None  # Track siblings for NEXT_SIBLING edges
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.nodes = []
        self.edges = []
        self.nodes_by_id = {}
        self.element_to_children = {}
        self.element_to_text = {}
        self.previous_sibling = {}
    
    def compute_element_hash(self, path: str) -> str:
        """
        Compute stable element hash based on position in tree
        
        Args:
            path: Structural path like "html[0]/body[1]/div[2]"
        
        Returns:
            Hash string like "elem_a1b2c3d4e5"
        """
        return f"elem_{str_md5(path)[:10]}"
    
    def compute_text_hash(self, text: str) -> str:
        """
        Compute text hash based on content
        
        Args:
            text: Text content
        
        Returns:
            Hash string like "text_abc123def0"
        """
        return f"text_{str_md5(text)[:10]}"
    
    def compute_attribute_hash(self, element_id: str, attr_name: str, attr_value: str) -> str:
        """
        Compute attribute hash based on element + name + value
        
        Args:
            element_id: Parent element's hash
            attr_name: Attribute name
            attr_value: Attribute value
        
        Returns:
            Hash string like "attr_xyz789pqr0"
        """
        signature = f"{element_id}:{attr_name}={attr_value}"
        return f"attr_{str_md5(signature)[:10]}"
    
    def compute_edge_hash(self, edge_type: str, source_id: str, target_id: str) -> str:
        """
        Compute edge hash based on type + source + target
        
        Args:
            edge_type: Type of edge
            source_id: Source node ID
            target_id: Target node ID
        
        Returns:
            Hash string like "edge_def456ghi0"
        """
        signature = f"{edge_type}:{source_id}‚Üí{target_id}"
        return f"edge_{str_md5(signature)[:10]}"
    
    def create_element_node(self, node_dict: Dict, path: str, depth: int, sibling_index: int
                            ) -> Schema__Graph__Node__Element:
        """Create element node from html_dict node"""
        element_id = self.compute_element_hash(path)
        
        element_node = Schema__Graph__Node__Element(
            node_id       = element_id,
            node_type     = "element",
            tag           = node_dict.get('tag'),
            depth         = depth,
            path          = path,
            sibling_index = sibling_index
        )
        
        return element_node
    
    def create_text_node(self, text: str, parent_id: str, path: str, depth: int,
                         is_hash: bool = False, original_text: str = None
                         ) -> Schema__Graph__Node__Text:
        """Create text node"""
        text_id = self.compute_text_hash(original_text if original_text else text)
        
        text_node = Schema__Graph__Node__Text(
            node_id       = text_id,
            node_type     = "text",
            text          = text,
            is_hash       = is_hash,
            original_text = original_text,
            parent_id     = parent_id,
            depth         = depth,
            path          = path
        )
        
        return text_node
    
    def create_attribute_nodes(self, attrs: Dict, element_id: str, element_path: str, depth: int
                                ) -> List[Schema__Graph__Node__Attribute]:
        """Create attribute nodes for an element"""
        attr_nodes = []
        
        for attr_name, attr_value in attrs.items():
            attr_id = self.compute_attribute_hash(element_id, attr_name, str(attr_value))
            
            attr_node = Schema__Graph__Node__Attribute(
                node_id         = attr_id,
                node_type       = "attribute",
                attribute_name  = attr_name,
                attribute_value = str(attr_value),
                element_id      = element_id,
                depth           = depth,
                path            = f"{element_path}/@{attr_name}"
            )
            
            attr_nodes.append(attr_node)
        
        return attr_nodes
    
    def create_edge(self, edge_type: str, source_id: str, target_id: str,
                    properties: Dict = None) -> Schema__Graph__Edge:
        """Create an edge between two nodes"""
        edge_id = self.compute_edge_hash(edge_type, source_id, target_id)
        
        edge = Schema__Graph__Edge(
            edge_id    = edge_id,
            edge_type  = edge_type,
            source_id  = source_id,
            target_id  = target_id,
            properties = properties
        )
        
        return edge
    
    def traverse(self, node_dict: Dict, parent_id: str = None, path: str = "",
                 depth: int = 0, sibling_index: int = 0) -> str:
        """
        Recursively traverse html_dict and build graph
        
        Args:
            node_dict: Current node from html_dict
            parent_id: Parent element's node_id
            path: Current structural path
            depth: Current depth in tree
            sibling_index: Position among siblings
        
        Returns:
            node_id of created node
        """
        if not isinstance(node_dict, dict):
            return None
        
        # Handle TEXT nodes
        if node_dict.get('type') == 'TEXT':
            text_data = node_dict.get('data', '').strip()
            if not text_data:
                return None
            
            text_path = f"{path}/text[{sibling_index}]"
            text_node = self.create_text_node(text_data, parent_id, text_path, depth)
            
            self.nodes.append(text_node)
            self.nodes_by_id[text_node.node_id] = text_node
            
            # Create CONTAINS edge
            if parent_id:
                edge = self.create_edge(EDGE_TYPE_CONTAINS, parent_id, text_node.node_id)
                self.edges.append(edge)
                
                # Track element‚Üítext mapping
                if parent_id not in self.element_to_text:
                    self.element_to_text[parent_id] = []
                self.element_to_text[parent_id].append(text_node.node_id)
            
            return text_node.node_id
        
        # Handle ELEMENT nodes
        tag = node_dict.get('tag')
        if not tag:
            return None
        
        # Build path
        current_path = f"{path}/{tag}[{sibling_index}]" if path else f"{tag}[{sibling_index}]"
        
        # Create element node
        element_node = self.create_element_node(node_dict, current_path, depth, sibling_index)
        self.nodes.append(element_node)
        self.nodes_by_id[element_node.node_id] = element_node
        
        # Create HAS_CHILD edge from parent
        if parent_id:
            edge = self.create_edge(EDGE_TYPE_HAS_CHILD, parent_id, element_node.node_id)
            self.edges.append(edge)
            
            # Track parent‚Üíchildren
            if parent_id not in self.element_to_children:
                self.element_to_children[parent_id] = []
            self.element_to_children[parent_id].append(element_node.node_id)
        
        # Handle attributes
        if self.include_attributes:
            attrs = node_dict.get('attrs', {})
            if attrs:
                attr_nodes = self.create_attribute_nodes(attrs, element_node.node_id, 
                                                          current_path, depth)
                for attr_node in attr_nodes:
                    self.nodes.append(attr_node)
                    self.nodes_by_id[attr_node.node_id] = attr_node
                    
                    # Create HAS_ATTRIBUTE edge
                    edge = self.create_edge(EDGE_TYPE_HAS_ATTRIBUTE, 
                                           element_node.node_id, attr_node.node_id)
                    self.edges.append(edge)
        
        # Traverse children
        children = node_dict.get('nodes', [])
        prev_child_id = None
        
        for idx, child in enumerate(children):
            child_id = self.traverse(child, element_node.node_id, current_path, 
                                     depth + 1, idx)
            
            # Create NEXT_SIBLING edge
            if prev_child_id and child_id:
                edge = self.create_edge(EDGE_TYPE_NEXT_SIBLING, prev_child_id, child_id)
                self.edges.append(edge)
                
                # Optionally create reverse PREV_SIBLING edge
                # edge_prev = self.create_edge(EDGE_TYPE_PREV_SIBLING, child_id, prev_child_id)
                # self.edges.append(edge_prev)
            
            prev_child_id = child_id
        
        return element_node.node_id
    
    def build_graph(self) -> Tuple[List, List]:
        """
        Build complete graph from html_dict
        
        Returns:
            Tuple of (nodes, edges)
        """
        if not self.html_dict:
            return [], []
        
        # Start traversal from root
        self.traverse(self.html_dict, parent_id=None, path="", depth=0, sibling_index=0)
        
        return self.nodes, self.edges
    
    def build_lookup_maps(self) -> Dict:
        """
        Build efficient lookup maps for querying
        
        Returns:
            Dict of lookup maps
        """
        nodes_by_type = {}
        elements_by_tag = {}
        element_to_attrs = {}
        text_to_element = {}
        
        for node in self.nodes:
            # Group by node type
            node_type = node.node_type
            if node_type not in nodes_by_type:
                nodes_by_type[node_type] = []
            nodes_by_type[node_type].append(node.node_id)
            
            # Group elements by tag
            if node_type == "element":
                tag = node.tag
                if tag not in elements_by_tag:
                    elements_by_tag[tag] = []
                elements_by_tag[tag].append(node.node_id)
            
            # Map text to parent element
            if node_type == "text":
                text_to_element[node.node_id] = node.parent_id
            
            # Map attributes to elements
            if node_type == "attribute":
                element_id = node.element_id
                if element_id not in element_to_attrs:
                    element_to_attrs[element_id] = []
                element_to_attrs[element_id].append(node.node_id)
        
        return {
            'nodes_by_type': nodes_by_type,
            'elements_by_tag': elements_by_tag,
            'element_to_children': self.element_to_children,
            'element_to_text': self.element_to_text,
            'element_to_attrs': element_to_attrs,
            'text_to_element': text_to_element
        }
```

---

## üìÅ File Structure

### New Files to Create

```
mgraph_ai_service_html/
‚îú‚îÄ‚îÄ html__fast_api/
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Html__To__Graph.py                              # NEW: Core graph builder
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Routes__Html.py                                 # MODIFY: Add 2 graph methods
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ schemas/
‚îÇ       ‚îî‚îÄ‚îÄ graph/                                          # NEW: Graph schemas directory
‚îÇ           ‚îú‚îÄ‚îÄ __init__.py                                 # NEW
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Node__Base.py                # NEW: Base node
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Node__Element.py             # NEW: Element node
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Node__Text.py                # NEW: Text node
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Node__Attribute.py           # NEW: Attribute node
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Node__Script.py              # NEW: Script node
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Node__Style.py               # NEW: Style node
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Node__Comment.py             # NEW: Comment node
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Graph__Edge.py                      # NEW: Edge definition
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Html__To__Graph__Request.py         # NEW
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Html__To__Graph__Response.py        # NEW
‚îÇ           ‚îú‚îÄ‚îÄ Schema__Html__To__Graph__With__Text__Hashes__Request.py   # NEW
‚îÇ           ‚îî‚îÄ‚îÄ Schema__Html__To__Graph__With__Text__Hashes__Response.py  # NEW
```

---

## üíª Implementation: Route Methods

### Method 1: `Routes__Html.to__graph()`

```python
def to__graph(self, request: Schema__Html__To__Graph__Request
               ) -> Schema__Html__To__Graph__Response:
    """
    Convert HTML to complete graph representation.
    
    Returns nodes (elements, text, attributes, etc.) and edges (relationships).
    Enables powerful graph queries and traversals.
    """
    from mgraph_ai_service_html.html__fast_api.core.Html__To__Graph import Html__To__Graph
    
    # Parse HTML to dict
    html_dict = self.html_direct_transformations.html__to__html_dict(request.html)
    
    # Build graph
    graph_builder = Html__To__Graph(
        html_dict          = html_dict,
        include_attributes = request.include_attributes,
        include_scripts    = request.include_scripts,
        include_styles     = request.include_styles,
        include_comments   = request.include_comments
    )
    
    nodes, edges = graph_builder.build_graph()
    lookup_maps = graph_builder.build_lookup_maps()
    
    # Calculate metrics
    total_elements = len(lookup_maps['nodes_by_type'].get('element', []))
    total_text = len(lookup_maps['nodes_by_type'].get('text', []))
    total_attrs = len(lookup_maps['nodes_by_type'].get('attribute', []))
    max_depth_val = max([n.depth for n in nodes]) if nodes else 0
    
    return Schema__Html__To__Graph__Response(
        nodes               = nodes,
        edges               = edges,
        nodes_by_id         = graph_builder.nodes_by_id,
        nodes_by_type       = lookup_maps['nodes_by_type'],
        elements_by_tag     = lookup_maps['elements_by_tag'],
        element_to_children = lookup_maps['element_to_children'],
        element_to_text     = lookup_maps['element_to_text'],
        element_to_attrs    = lookup_maps['element_to_attrs'],
        text_to_element     = lookup_maps['text_to_element'],
        total_nodes         = len(nodes),
        total_edges         = len(edges),
        total_elements      = total_elements,
        total_text_nodes    = total_text,
        total_attributes    = total_attrs,
        max_depth           = max_depth_val
    )
```

### Method 2: `Routes__Html.to__graph__with__text__hashes()`

```python
def to__graph__with__text__hashes(self, request: Schema__Html__To__Graph__With__Text__Hashes__Request
                                   ) -> Schema__Html__To__Graph__With__Text__Hashes__Response:
    """
    Convert HTML to graph with text nodes containing hashes.
    
    Combines graph representation with hash replacement workflow.
    Text nodes will have is_hash=True and original_text field populated.
    """
    from mgraph_ai_service_html.html__fast_api.core.Html__To__Graph import Html__To__Graph
    from mgraph_ai_service_html.html__fast_api.core.Html__Extract_Text_Nodes import Html__Extract_Text_Nodes
    
    # Parse HTML to dict
    html_dict = self.html_direct_transformations.html__to__html_dict(request.html)
    
    # Extract text and replace with hashes
    extractor = Html__Extract_Text_Nodes()
    extractor.html_dict = html_dict
    extractor.max_depth = request.max_depth
    extractor.traverse(html_dict, depth=0, parent_tag=None)
    text_hashes_mapping = extractor.text_elements__raw
    
    # Build graph from html_dict (now has hashes)
    graph_builder = Html__To__Graph(
        html_dict          = html_dict,
        include_attributes = request.include_attributes,
        include_scripts    = request.include_scripts,
        include_styles     = request.include_styles,
        include_comments   = request.include_comments
    )
    
    nodes, edges = graph_builder.build_graph()
    
    # Update text nodes to mark them as hashes
    for node in nodes:
        if node.node_type == "text":
            hash_value = node.text
            if hash_value in text_hashes_mapping:
                node.is_hash = True
                node.original_text = text_hashes_mapping[hash_value]
    
    lookup_maps = graph_builder.build_lookup_maps()
    
    # Calculate metrics
    total_elements = len(lookup_maps['nodes_by_type'].get('element', []))
    total_text = len(lookup_maps['nodes_by_type'].get('text', []))
    total_attrs = len(lookup_maps['nodes_by_type'].get('attribute', []))
    max_depth_val = max([n.depth for n in nodes]) if nodes else 0
    
    return Schema__Html__To__Graph__With__Text__Hashes__Response(
        nodes               = nodes,
        edges               = edges,
        html_dict           = html_dict,
        text_hashes_mapping = text_hashes_mapping,
        nodes_by_id         = graph_builder.nodes_by_id,
        nodes_by_type       = lookup_maps['nodes_by_type'],
        elements_by_tag     = lookup_maps['elements_by_tag'],
        element_to_children = lookup_maps['element_to_children'],
        element_to_text     = lookup_maps['element_to_text'],
        element_to_attrs    = lookup_maps['element_to_attrs'],
        text_to_element     = lookup_maps['text_to_element'],
        total_nodes         = len(nodes),
        total_edges         = len(edges),
        total_elements      = total_elements,
        total_text_nodes    = total_text,
        total_attributes    = total_attrs,
        max_depth           = max_depth_val
    )
```

**Route Registration**: Add to `Routes__Html.setup_routes()`:
```python
def setup_routes(self):
    self.add_route_post(self.to__dict         )
    self.add_route_post(self.to__html         )
    self.add_route_post(self.to__text__nodes  )
    self.add_route_post(self.to__lines        )
    self.add_route_post(self.to__html__hashes )
    self.add_route_post(self.to__html__xxx    )
    self.add_route_post(self.to__dict__hashes )             # From BRIEF-001
    self.add_route_post(self.to__text__hashes )             # From BRIEF-001
    self.add_route_post(self.to__graph        )             # NEW: Graph
    self.add_route_post(self.to__graph__with__text__hashes) # NEW: Graph + Hashes
```

---

## üìä Example: Complete Graph Output

### Input HTML:
```html
<html>
  <body>
    <div class="container">
      <h1>Hello</h1>
      <p>World</p>
    </div>
  </body>
</html>
```

### Output (Simplified):
```json
{
  "nodes": [
    {
      "node_id": "elem_a1a1a1a1a1",
      "node_type": "element",
      "tag": "html",
      "depth": 0,
      "path": "html[0]",
      "sibling_index": 0
    },
    {
      "node_id": "elem_b2b2b2b2b2",
      "node_type": "element",
      "tag": "body",
      "depth": 1,
      "path": "html[0]/body[0]",
      "sibling_index": 0
    },
    {
      "node_id": "elem_c3c3c3c3c3",
      "node_type": "element",
      "tag": "div",
      "depth": 2,
      "path": "html[0]/body[0]/div[0]",
      "sibling_index": 0
    },
    {
      "node_id": "attr_d4d4d4d4d4",
      "node_type": "attribute",
      "attribute_name": "class",
      "attribute_value": "container",
      "element_id": "elem_c3c3c3c3c3",
      "depth": 2,
      "path": "html[0]/body[0]/div[0]/@class"
    },
    {
      "node_id": "elem_e5e5e5e5e5",
      "node_type": "element",
      "tag": "h1",
      "depth": 3,
      "path": "html[0]/body[0]/div[0]/h1[0]",
      "sibling_index": 0
    },
    {
      "node_id": "text_f6f6f6f6f6",
      "node_type": "text",
      "text": "Hello",
      "is_hash": false,
      "parent_id": "elem_e5e5e5e5e5",
      "depth": 4,
      "path": "html[0]/body[0]/div[0]/h1[0]/text[0]"
    },
    {
      "node_id": "elem_g7g7g7g7g7",
      "node_type": "element",
      "tag": "p",
      "depth": 3,
      "path": "html[0]/body[0]/div[0]/p[1]",
      "sibling_index": 1
    },
    {
      "node_id": "text_h8h8h8h8h8",
      "node_type": "text",
      "text": "World",
      "is_hash": false,
      "parent_id": "elem_g7g7g7g7g7",
      "depth": 4,
      "path": "html[0]/body[0]/div[0]/p[1]/text[0]"
    }
  ],
  "edges": [
    {
      "edge_id": "edge_001",
      "edge_type": "HAS_CHILD",
      "source_id": "elem_a1a1a1a1a1",
      "target_id": "elem_b2b2b2b2b2"
    },
    {
      "edge_id": "edge_002",
      "edge_type": "HAS_CHILD",
      "source_id": "elem_b2b2b2b2b2",
      "target_id": "elem_c3c3c3c3c3"
    },
    {
      "edge_id": "edge_003",
      "edge_type": "HAS_ATTRIBUTE",
      "source_id": "elem_c3c3c3c3c3",
      "target_id": "attr_d4d4d4d4d4"
    },
    {
      "edge_id": "edge_004",
      "edge_type": "HAS_CHILD",
      "source_id": "elem_c3c3c3c3c3",
      "target_id": "elem_e5e5e5e5e5"
    },
    {
      "edge_id": "edge_005",
      "edge_type": "HAS_CHILD",
      "source_id": "elem_c3c3c3c3c3",
      "target_id": "elem_g7g7g7g7g7"
    },
    {
      "edge_id": "edge_006",
      "edge_type": "NEXT_SIBLING",
      "source_id": "elem_e5e5e5e5e5",
      "target_id": "elem_g7g7g7g7g7"
    },
    {
      "edge_id": "edge_007",
      "edge_type": "CONTAINS",
      "source_id": "elem_e5e5e5e5e5",
      "target_id": "text_f6f6f6f6f6"
    },
    {
      "edge_id": "edge_008",
      "edge_type": "CONTAINS",
      "source_id": "elem_g7g7g7g7g7",
      "target_id": "text_h8h8h8h8h8"
    }
  ],
  "nodes_by_type": {
    "element": ["elem_a1a1a1a1a1", "elem_b2b2b2b2b2", "elem_c3c3c3c3c3", "elem_e5e5e5e5e5", "elem_g7g7g7g7g7"],
    "text": ["text_f6f6f6f6f6", "text_h8h8h8h8h8"],
    "attribute": ["attr_d4d4d4d4d4"]
  },
  "elements_by_tag": {
    "html": ["elem_a1a1a1a1a1"],
    "body": ["elem_b2b2b2b2b2"],
    "div": ["elem_c3c3c3c3c3"],
    "h1": ["elem_e5e5e5e5e5"],
    "p": ["elem_g7g7g7g7g7"]
  },
  "element_to_text": {
    "elem_e5e5e5e5e5": ["text_f6f6f6f6f6"],
    "elem_g7g7g7g7g7": ["text_h8h8h8h8h8"]
  },
  "total_nodes": 8,
  "total_edges": 8,
  "total_elements": 5,
  "total_text_nodes": 2,
  "total_attributes": 1,
  "max_depth": 4
}
```

---

## üéØ Use Cases & Query Examples

### Use Case 1: Find All Text in Specific Elements
```python
# Find all text in <p> tags
p_elements = response.elements_by_tag.get('p', [])
all_p_text = []
for p_id in p_elements:
    text_ids = response.element_to_text.get(p_id, [])
    for text_id in text_ids:
        text_node = response.nodes_by_id[text_id]
        all_p_text.append(text_node.text)
```

### Use Case 2: Find Parent of Text Node
```python
# Given a text node ID, find its parent element
text_id = "text_abc123"
parent_id = response.text_to_element[text_id]
parent_node = response.nodes_by_id[parent_id]
print(f"Text is in <{parent_node.tag}> element")
```

### Use Case 3: Get All Attributes of Element
```python
# Get all attributes of a specific element
element_id = "elem_xyz789"
attr_ids = response.element_to_attrs.get(element_id, [])
attributes = {}
for attr_id in attr_ids:
    attr_node = response.nodes_by_id[attr_id]
    attributes[attr_node.attribute_name] = attr_node.attribute_value
```

### Use Case 4: Traverse Parent Chain
```python
# Get all ancestors of a node
def get_ancestors(node_id, response):
    ancestors = []
    current = response.nodes_by_id[node_id]
    
    while current.path:
        # Extract parent path
        parts = current.path.rsplit('/', 1)
        if len(parts) < 2:
            break
        parent_path = parts[0]
        
        # Find parent node
        for node in response.nodes:
            if node.path == parent_path:
                ancestors.append(node)
                current = node
                break
        else:
            break
    
    return ancestors
```

### Use Case 5: Admin UI - Visual Graph Display
```javascript
// In Admin UI, render graph with D3.js
const nodes = response.nodes.map(n => ({
    id: n.node_id,
    label: n.node_type === 'text' ? n.text : `<${n.tag}>`,
    type: n.node_type,
    depth: n.depth
}));

const links = response.edges.map(e => ({
    source: e.source_id,
    target: e.target_id,
    type: e.edge_type
}));

// Create force-directed graph
d3ForceGraph()
    .graphData({ nodes, links })
    .nodeLabel('label')
    .linkLabel('type');
```

---

## üß™ Testing Requirements

### Unit Tests

```python
class Test_Html__To__Graph:
    
    def test_simple_html_graph(self):
        """Test basic HTML to graph conversion"""
        html = "<p>Hello</p>"
        
        # ... build graph
        
        assert len(nodes) == 2  # element + text
        assert len(edges) == 1  # CONTAINS
    
    def test_nested_elements(self):
        """Test nested elements create correct edges"""
        html = "<div><p>Text</p></div>"
        
        # Should have: html‚Üíbody‚Üídiv‚Üíp‚Üítext
        # Edges: HAS_CHILD between elements, CONTAINS for text
    
    def test_attributes(self):
        """Test attribute nodes created"""
        html = '<div class="test" id="main">Content</div>'
        
        # Should have attribute nodes for class and id
        # Should have HAS_ATTRIBUTE edges
    
    def test_siblings(self):
        """Test sibling edges created"""
        html = "<div><p>First</p><p>Second</p></div>"
        
        # Should have NEXT_SIBLING edge between two <p> elements
    
    def test_element_hash_stable(self):
        """Test element hashes based on position"""
        html = "<div><p>A</p><p>B</p></div>"
        
        # Same position = same hash across runs
    
    def test_lookup_maps(self):
        """Test all lookup maps populated correctly"""
        # Test nodes_by_type, elements_by_tag, etc.
```

### Integration Tests

```python
def test_graph_endpoint(client):
    """Test /html/to__graph endpoint"""
    response = client.post(
        "/html/to/graph",
        json={
            "html": "<div><p>Test</p></div>",
            "include_attributes": True
        }
    )
    
    assert response.status_code == 200
    data = response.json()
    assert "nodes" in data
    assert "edges" in data
    assert len(data["nodes"]) > 0

def test_graph_with_hashes_endpoint(client):
    """Test /html/to__graph__with__text__hashes endpoint"""
    response = client.post(
        "/html/to/graph/with/text/hashes",
        json={
            "html": "<p>Test</p>"
        }
    )
    
    assert response.status_code == 200
    data = response.json()
    assert "nodes" in data
    assert "text_hashes_mapping" in data
    
    # Verify text nodes have is_hash=True
    text_nodes = [n for n in data["nodes"] if n["node_type"] == "text"]
    assert all(n["is_hash"] for n in text_nodes)
```

---

## ‚úÖ Implementation Checklist

### Schema Files (11 files)
- [ ] `Schema__Graph__Node__Base.py`
- [ ] `Schema__Graph__Node__Element.py`
- [ ] `Schema__Graph__Node__Text.py`
- [ ] `Schema__Graph__Node__Attribute.py`
- [ ] `Schema__Graph__Node__Script.py`
- [ ] `Schema__Graph__Node__Style.py`
- [ ] `Schema__Graph__Node__Comment.py`
- [ ] `Schema__Graph__Edge.py`
- [ ] `Schema__Html__To__Graph__Request.py`
- [ ] `Schema__Html__To__Graph__Response.py`
- [ ] `Schema__Html__To__Graph__With__Text__Hashes__Request.py`
- [ ] `Schema__Html__To__Graph__With__Text__Hashes__Response.py`

### Core Implementation
- [ ] `Html__To__Graph.py` - Complete graph builder class
- [ ] All node computation methods
- [ ] All edge creation methods
- [ ] Traversal logic
- [ ] Lookup map generation

### Route Methods
- [ ] `Routes__Html.to__graph()` implementation
- [ ] `Routes__Html.to__graph__with__text__hashes()` implementation
- [ ] Route registration in `setup_routes()`

### Testing
- [ ] Unit tests for `Html__To__Graph` class
- [ ] Unit tests for node/edge creation
- [ ] Integration tests for endpoints
- [ ] Test lookup maps
- [ ] Test with complex HTML
- [ ] Performance tests for large HTML

### Documentation
- [ ] OpenAPI docs updated
- [ ] README examples added
- [ ] Query examples documented

---

## üöÄ Future Extensions

### Phase 1: Basic Graph (This Brief)
- Elements, Text, Attributes, Scripts, Styles, Comments
- Basic edges (HAS_CHILD, CONTAINS, etc.)

### Phase 2: JavaScript Text Extraction (Future)
- Extract string literals from inline scripts
- New node type: `Schema__Graph__Node__Javascript__Text`
- Parse JavaScript AST
- Extract template literals

### Phase 3: JSON Data Extraction (Future)
- Extract strings from JSON in script tags
- New node type: `Schema__Graph__Node__Json__Text`
- JSON path for each string

### Phase 4: CSS Text Extraction (Future)
- Extract content from CSS (`content: "..."`)
- Extract data URLs with text

### Phase 5: Graph Queries (Future)
- Query language for graph traversal
- Filter nodes/edges
- Path queries (XPath-like)

### Phase 6: Graph Export (Future)
- Export to GraphML
- Export to Neo4j
- Export to RDF

---

## üéØ Success Metrics

### Functional Success
‚úÖ Graph accurately represents HTML structure  
‚úÖ All node types properly created  
‚úÖ All edge types properly created  
‚úÖ Position-based hashing works correctly  
‚úÖ Lookup maps enable efficient queries  
‚úÖ Integration with hash workflow works  

### Performance Success
‚úÖ Graph building completes in < 2 seconds for typical HTML  
‚úÖ Memory usage reasonable for large HTML  
‚úÖ Lookup maps enable O(1) queries  

### Code Quality Success
‚úÖ Type-safe schemas for all nodes/edges  
‚úÖ Clean separation of concerns  
‚úÖ Comprehensive docstrings  
‚úÖ No lint errors  
‚úÖ 90%+ test coverage  

---

## üö® Critical Notes

### Dependencies
- This brief assumes BRIEF-001 is already implemented
- Uses `Html__Extract_Text_Nodes` from BRIEF-001
- Compatible with hash workflow from BRIEF-001

### Performance Considerations
- Large HTML documents will create many nodes/edges
- Lookup maps are essential for performance
- Consider pagination for very large graphs

### Extensibility
- Node system is designed for easy extension
- Add new node types by inheriting from base
- Add new edge types by adding constants