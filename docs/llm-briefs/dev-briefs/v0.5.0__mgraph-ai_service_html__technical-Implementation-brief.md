# MGraph-AI__Service__Html - Technical Implementation Brief

**Version:** v0.1.23  
**Date:** October 15, 2025  
**Purpose:** Complete technical specification for refactoring MGraph-AI__Web-Content-Filtering to MGraph-AI__Service__Html  
**Audience:** LLM assistants implementing the refactoring

---

## Executive Summary

This document specifies the refactoring of `MGraph-AI__Web-Content-Filtering` into `MGraph-AI__Service__Html`, a pure HTML structural transformation service. The key insight is **separation of concerns**: HTML structural operations (fast, deterministic) must be separated from semantic text analysis (slow, AI-dependent).

**Critical Change:** Remove ALL LLM dependencies. This service handles HTML structure only. A separate service (`MGraph-AI__Service__Semantic_Text`) will handle text analysis.

---

## Service Architecture

### Service Separation Strategy

```
┌─────────────────────────────────────────────────────────────┐
│                    Mitmproxy                                │
│                  (HTML Interception)                        │
└────────────────────────┬────────────────────────────────────┘
                         │ Raw HTML
                         ▼
┌─────────────────────────────────────────────────────────────┐
│           MGraph-AI__Service__Html                          │ ← THIS SERVICE
│                                                             │
│  Responsibilities:                                          │
│  • HTML ↔ html_dict conversion                             │
│  • Text node extraction with stable hashes                 │
│  • HTML reconstruction from hash mappings                  │
│  • Visual transformations (hashes, xxx masks)              │
│  • Structure validation (round-trip testing)               │
│                                                             │
│  NOT responsible for:                                       │
│  • LLM API calls                                           │
│  • Content rating/sentiment analysis                       │
│  • Topic extraction                                        │
│  • Caching (caller's responsibility)                       │
└────────────────────────┬────────────────────────────────────┘
                         │ {hash: text} mappings
                         ▼
┌─────────────────────────────────────────────────────────────┐
│      MGraph-AI__Service__Semantic_Text                      │ ← SEPARATE SERVICE
│                                                             │
│  • Text → LLM ratings                                      │
│  • Sentiment analysis                                      │
│  • Topic extraction                                        │
│  • Content classification                                  │
└─────────────────────────────────────────────────────────────┘
```

### Why "Html" Not "Web-Content-Filtering"?

**Naming Evolution:**
- **Was:** `MGraph-AI__Web-Content-Filtering` (WCF)
- **Now:** `MGraph-AI__Service__Html`

**Rationale:**
1. **Accuracy:** Service doesn't filter - it transforms HTML structure
2. **Simplicity:** Short, clear, fits established naming pattern
3. **Scope Clarity:** "Html" immediately indicates structural operations only
4. **MGraph Ecosystem:** Aligns with `MGraph-AI__Service__LLMs`, `MGraph-AI__Service__Cache`, etc.

**Package name:** `mgraph_ai_service_html`

---

## Transformation Pipeline Architecture

### Core Insight: Granular vs Compound Operations

The service exposes both **atomic** and **compound** operations to give callers maximum control over caching and processing strategies.

```
                        ┌──────────────┐
                        │ HTML (string)│ ← From Mitmproxy
                        └──────┬───────┘
                               │
                        [html_to_dict] ← ATOMIC: cacheable step
                               │
                               ▼
                        ┌──────────────┐
                        │  html_dict   │ ← Core structure (JSON)
                        └──────┬───────┘
                               │
                  ┌────────────┴────────────┐
                  │                         │
          [dict_to_text_nodes]      [dict_to_html] ← ATOMIC: cacheable steps
                  │                         │
                  ▼                         ▼
           ┌─────────────┐           ┌──────────┐
           │ text_nodes  │           │   HTML   │ ← ROUND-TRIP validation
           │ {hash:data} │           └──────────┘
           └──────┬──────┘
                  │
        ┌─────────┼─────────┐
        │         │         │
        ▼         ▼         ▼
     hashes     xxx      [merge]
      HTML      HTML        │
                            ├─ + ratings → filtered HTML (external)
                            └─ + custom  → custom HTML
```

### Why Both Atomic and Compound?

**Atomic Operations:**
- Maximum caching control
- High-volume sites cache each step
- Debug individual transformations
- Example: Cache `html_dict` for 1 hour, `text_nodes` indefinitely

**Compound Operations:**
- Convenience for low-volume sites
- Simpler API integration
- Less network overhead
- Example: One-shot HTML → text_nodes extraction

---

## Complete Endpoint Specification

### Routes__Html (tag: `html`)

#### Atomic Operations

```python
POST /html/to/dict
Request:  Schema__Html__To__Dict__Request
Response: Schema__Html__To__Dict__Response
Purpose:  Parse HTML string into html_dict structure
Caching:  Caller should cache html_dict by URL/content hash
Use when: High-volume site, need to reuse parsed structure

POST /html/to/html
Request:  Schema__Html__To__Html__Request
Response: HTMLResponse
Purpose:  Round-trip validation (HTML → dict → HTML)
Critical: This tests transformation fidelity - if output differs from input, transformation is lossy
Use when: Quality assurance, regression testing
```

#### Compound Operations

```python
POST /html/to/text/nodes
Request:  Schema__Html__To__Text__Nodes__Request
Response: Schema__Html__To__Text__Nodes__Response
Purpose:  HTML → dict → text_nodes in one call
Use when: Don't need to cache html_dict separately

POST /html/to/lines
Request:  Schema__Html__To__Lines__Request
Response: PlainTextResponse
Purpose:  HTML → dict → formatted line representation
Use when: Debugging, human-readable output

POST /html/to/html/hashes
Request:  Schema__Html__To__Html__Hashes__Request
Response: HTMLResponse
Purpose:  Replace all text with hashes (visual debug)
Use when: Verify hash extraction, debug text identification

POST /html/to/html/xxx
Request:  Schema__Html__To__Html__Xxx__Request
Response: HTMLResponse
Purpose:  Replace all text with 'x' characters (privacy mask)
Use when: Preserve structure while hiding content
```

### Routes__Dict (tag: `dict`)

```python
POST /dict/to/html
Request:  Schema__Dict__To__Html__Request
Response: HTMLResponse
Purpose:  Reconstruct HTML from html_dict
Use when: Have cached html_dict, need HTML output

POST /dict/to/text/nodes
Request:  Schema__Dict__To__Text__Nodes__Request
Response: Schema__Dict__To__Text__Nodes__Response
Purpose:  Extract text nodes from html_dict
Use when: Have cached html_dict, need text extraction

POST /dict/to/lines
Request:  Schema__Dict__To__Lines__Request
Response: PlainTextResponse
Purpose:  Format html_dict as readable lines
Use when: Debugging, inspection
```

### Routes__Hashes (tag: `hashes`)

```python
POST /hashes/to/html
Request:  Schema__Hashes__To__Html__Request
Response: HTMLResponse
Purpose:  Reconstruct HTML with custom text replacements
Critical: This is how external services (like Semantic_Text) modify HTML
Use when: Have ratings/modifications from external service
```

---

## Request/Response Schema Definitions

### Type_Safe Schema Classes

**CRITICAL:** All schemas must follow Type_Safe patterns from the guidance documents:
- Inherit from `Type_Safe`
- All attributes typed with Safe_* primitives
- Inline comments aligned at column 80
- NO docstrings
- Use context managers in tests

```python
from osbot_utils.type_safe.Type_Safe                                                    import Type_Safe
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Html             import Safe_Str__Html
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash     import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                                    import Safe_UInt
from typing                                                                             import Dict

# ============ Atomic Operation Schemas ============

class Schema__Html__To__Dict__Request(Type_Safe):                # Parse HTML to dict
    html: Safe_Str__Html                                         # Raw HTML content (1MB limit)

class Schema__Html__To__Dict__Response(Type_Safe):               # Parsed structure
    html_dict    : Dict                                          # Full html_dict structure
    node_count   : Safe_UInt                                     # Total nodes in tree
    max_depth    : Safe_UInt                                     # Deepest nesting level

class Schema__Dict__To__Html__Request(Type_Safe):                # Reconstruct HTML
    html_dict: Dict                                              # html_dict structure

class Schema__Dict__To__Html__Response(Type_Safe):               # Reconstructed HTML
    html: Safe_Str__Html                                         # Reconstructed HTML string

class Schema__Dict__To__Text__Nodes__Request(Type_Safe):         # Extract text nodes
    html_dict: Dict                                              # html_dict structure
    max_depth: Safe_UInt = 256                                   # Maximum traversal depth

class Schema__Dict__To__Text__Nodes__Response(Type_Safe):        # Extracted nodes
    text_nodes       : Dict[Safe_Str__Hash, Dict]                # {hash: {text, tag}}
    total_nodes      : Safe_UInt                                 # Number of text nodes
    max_depth_reached: bool                                      # Hit depth limit?

# ============ Compound Operation Schemas ============

class Schema__Html__To__Text__Nodes__Request(Type_Safe):         # One-shot extraction
    html     : Safe_Str__Html                                    # Raw HTML content
    max_depth: Safe_UInt = 256                                   # Maximum traversal depth

class Schema__Html__To__Html__Request(Type_Safe):                # Round-trip validation
    html: Safe_Str__Html                                         # HTML to validate

class Schema__Html__To__Html__Hashes__Request(Type_Safe):        # Visual debug
    html     : Safe_Str__Html                                    # Raw HTML content
    max_depth: Safe_UInt = 256                                   # Maximum traversal depth

class Schema__Html__To__Html__Xxx__Request(Type_Safe):           # Privacy mask
    html     : Safe_Str__Html                                    # Raw HTML content
    max_depth: Safe_UInt = 256                                   # Maximum traversal depth

class Schema__Html__To__Lines__Request(Type_Safe):               # Formatted output
    html: Safe_Str__Html                                         # Raw HTML content

# ============ Hash Reconstruction Schema ============

class Schema__Hashes__To__Html__Request(Type_Safe):              # Merge external modifications
    html_dict   : Dict                                           # Original structure
    hash_mapping: Dict[Safe_Str__Hash, str]                      # {hash: replacement_text}
```

### Schema Design Principles

1. **Request/Response Pairs:** Every operation has explicit request and response schemas
2. **Safe Types:** Use appropriate Safe_* primitives, never raw str/int/float
3. **Optional Parameters:** Use defaults for optional parameters (max_depth, etc.)
4. **Metadata:** Include useful metadata in responses (counts, flags)
5. **Type Safety:** Dict typing should be as specific as possible

---

## Core Component Refactoring

### Components to Remove

```python
# DELETE these files - they belong in Semantic_Text service:
mgraph_ai_web_content_filtering/wcf__fast_api/llms/
├── API__LLM__Open_Router.py                                     # ❌ Remove
├── LLM__Prompt__Extract_Rating.py                               # ❌ Remove
├── Schema__Text__Rating.py                                      # ❌ Remove
├── Schema__WCF__LLM__Supported_Models.py                        # ❌ Remove
├── WCF__LLM__Cache.py                                           # ❌ Remove
└── WCF__LLM__Execute_Request.py                                 # ❌ Remove

# DELETE these route methods - they require LLM:
Routes__Html_Graphs:
├── url_to_ratings()                                             # ❌ Remove
├── url_to_html_ratings()                                        # ❌ Remove
├── url_to_html_min_rating()                                     # ❌ Remove
├── url_to_html_max_rating()                                     # ❌ Remove
└── url_to_html_topics()                                         # ❌ Remove
```

### Components to Modify

```python
# MODIFY Html__Extract_Text_Nodes
# Current: Requires url parameter, uses Html__Transformations
# New: Accept html_dict directly, no URL dependency

class Html__Extract_Text_Nodes(Type_Safe):
    html_dict          : Dict = None                             # Can be set directly
    text_elements      : Dict
    text_elements__raw : Dict
    hash_size          : int  = 10
    captures           : int  = 0
    max_depth          : int  = 256
    
    def extract_from_html_dict(self, html_dict: Dict            ,# NEW METHOD: Direct extraction
                                      max_depth: int = 256
                                ) -> Dict:
        self.html_dict = html_dict
        self.max_depth = max_depth
        self.traverse(self.html_dict, depth=0, parent_tag=None)
        return self.text_elements
        
    # REMOVE these methods that require LLM:
    # - create_ratings()                                         # ❌ Remove
    # - create_html_with_ratings()                               # ❌ Remove
    # - create_html_with_topics()                                # ❌ Remove
    # - create_html_with_min_ratings()                           # ❌ Remove
    # - create_html_with_max_ratings()                           # ❌ Remove
```

### Components to Keep (No Changes)

```python
# KEEP these - they work with html_dict and don't need URL/LLM:
mgraph_ai_web_content_filtering/wcf__fast_api/core/
├── Html__Transformations.py                                     # ✅ Keep (remove cache logic)
└── __init__.py

# These utility classes are pure transformations:
from osbot_utils.helpers.html.transformers.Html__To__Html_Dict     import Html__To__Html_Dict
from osbot_utils.helpers.html.transformers.Html_Dict__To__Html     import Html_Dict__To__Html
from osbot_utils.helpers.html.transformers.Html__To__Html_Document import Html__To__Html_Document
```

### New Components to Create

```python
# CREATE new direct transformation class
class Html__Direct__Transformations(Type_Safe):                  # HTML processing without URL/cache
    
    def html__to__html_dict(self, html: Safe_Str__Html) -> Dict: # Parse HTML directly
        return Html__To__Html_Dict(html=html).convert()
        
    def html_dict__to__html(self, html_dict: Dict) -> str:       # Reconstruct HTML
        return Html_Dict__To__Html(root=html_dict).convert()
        
    def html__to__lines(self, html: Safe_Str__Html) -> str:      # Format as lines
        html_dict = self.html__to__html_dict(html)
        html_converter = Html__To__Html_Dict(html='')
        html_converter.root = html_dict
        return "\n".join(html_converter.print(just_return_lines=True))
        
    def html_dict__to__text_nodes(self, html_dict: Dict         ,# Extract text nodes
                                        max_depth: int = 256
                                   ) -> Dict:
        extractor = Html__Extract_Text_Nodes()
        return extractor.extract_from_html_dict(html_dict, max_depth)
```

---

## Routes Implementation Pattern

### Routes__Html Implementation

```python
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes
from starlette.responses                        import HTMLResponse, PlainTextResponse

class Routes__Html(Fast_API__Routes):                            # HTML transformation routes
    tag                        : str                       = 'html'
    html_direct_transformations: Html__Direct__Transformations = None
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.html_direct_transformations = Html__Direct__Transformations()
    
    # ========== Atomic Operations ==========
    
    def to__dict(self, request: Schema__Html__To__Dict__Request  # Parse HTML to dict
                  ) -> Schema__Html__To__Dict__Response:
        html_dict  = self.html_direct_transformations.html__to__html_dict(request.html)
        node_count = self._count_nodes(html_dict)
        max_depth  = self._calculate_max_depth(html_dict)
        
        return Schema__Html__To__Dict__Response(html_dict  = html_dict  ,
                                                node_count = node_count ,
                                                max_depth  = max_depth  )
    
    def to__html(self, request: Schema__Html__To__Html__Request  # Round-trip validation
                  ) -> HTMLResponse:
        html_dict = self.html_direct_transformations.html__to__html_dict(request.html)
        html      = self.html_direct_transformations.html_dict__to__html(html_dict)
        return HTMLResponse(content=html, status_code=200)
    
    # ========== Compound Operations ==========
    
    def to__text__nodes(self, request: Schema__Html__To__Text__Nodes__Request
                         ) -> Schema__Html__To__Text__Nodes__Response:
        html_dict  = self.html_direct_transformations.html__to__html_dict(request.html)
        text_nodes = self.html_direct_transformations.html_dict__to__text_nodes(html_dict, request.max_depth)
        
        return Schema__Html__To__Text__Nodes__Response(text_nodes        = text_nodes              ,
                                                       total_nodes       = len(text_nodes)         ,
                                                       max_depth_reached = self._check_depth(html_dict, request.max_depth))
    
    def to__lines(self, request: Schema__Html__To__Lines__Request
                   ) -> PlainTextResponse:
        lines = self.html_direct_transformations.html__to__lines(request.html)
        return PlainTextResponse(content=lines)
    
    def to__html__hashes(self, request: Schema__Html__To__Html__Hashes__Request
                          ) -> HTMLResponse:
        html_dict  = self.html_direct_transformations.html__to__html_dict(request.html)
        text_nodes = self.html_direct_transformations.html_dict__to__text_nodes(html_dict, request.max_depth)
        
        # Replace text with hashes in html_dict
        html_with_hashes = self._replace_text_with_hashes(html_dict, text_nodes)
        html = self.html_direct_transformations.html_dict__to__html(html_with_hashes)
        
        return HTMLResponse(content=html, status_code=200)
    
    def to__html__xxx(self, request: Schema__Html__To__Html__Xxx__Request
                       ) -> HTMLResponse:
        html_dict  = self.html_direct_transformations.html__to__html_dict(request.html)
        text_nodes = self.html_direct_transformations.html_dict__to__text_nodes(html_dict, request.max_depth)
        
        # Replace text with x's
        html_with_xxx = self._replace_text_with_xxx(html_dict, text_nodes)
        html = self.html_direct_transformations.html_dict__to__html(html_with_xxx)
        
        return HTMLResponse(content=html, status_code=200)
    
    # ========== Helper Methods ==========
    
    def _count_nodes(self, html_dict: Dict) -> int:              # Count nodes in tree
        # Implementation details
        pass
        
    def _calculate_max_depth(self, html_dict: Dict) -> int:      # Find deepest nesting
        # Implementation details
        pass
        
    def _check_depth(self, html_dict: Dict, max_depth: int) -> bool:  # Hit depth limit?
        # Implementation details
        pass
        
    def _replace_text_with_hashes(self, html_dict: Dict, text_nodes: Dict) -> Dict:
        # Implementation: traverse html_dict, replace text with hashes
        pass
        
    def _replace_text_with_xxx(self, html_dict: Dict, text_nodes: Dict) -> Dict:
        # Implementation: traverse html_dict, replace text with x's
        pass
    
    def setup_routes(self):
        self.add_route_post(self.to__dict         )              # Atomic operations
        self.add_route_post(self.to__html         )
        self.add_route_post(self.to__text__nodes  )              # Compound operations
        self.add_route_post(self.to__lines        )
        self.add_route_post(self.to__html__hashes )
        self.add_route_post(self.to__html__xxx    )
```

### Routes__Dict Implementation

```python
class Routes__Dict(Fast_API__Routes):                            # Dict-based operations
    tag                        : str                       = 'dict'
    html_direct_transformations: Html__Direct__Transformations = None
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.html_direct_transformations = Html__Direct__Transformations()
    
    def to__html(self, request: Schema__Dict__To__Html__Request  # Reconstruct HTML
                  ) -> HTMLResponse:
        html = self.html_direct_transformations.html_dict__to__html(request.html_dict)
        return HTMLResponse(content=html, status_code=200)
    
    def to__text__nodes(self, request: Schema__Dict__To__Text__Nodes__Request
                         ) -> Schema__Dict__To__Text__Nodes__Response:
        text_nodes = self.html_direct_transformations.html_dict__to__text_nodes(request.html_dict, request.max_depth)
        
        return Schema__Dict__To__Text__Nodes__Response(text_nodes        = text_nodes       ,
                                                       total_nodes       = len(text_nodes)  ,
                                                       max_depth_reached = False            )  # TODO: implement
    
    def to__lines(self, request: Schema__Dict__To__Lines__Request
                   ) -> PlainTextResponse:
        html = self.html_direct_transformations.html_dict__to__html(request.html_dict)
        lines = self.html_direct_transformations.html__to__lines(html)
        return PlainTextResponse(content=lines)
    
    def setup_routes(self):
        self.add_route_post(self.to__html       )
        self.add_route_post(self.to__text__nodes)
        self.add_route_post(self.to__lines      )
```

### Routes__Hashes Implementation

```python
class Routes__Hashes(Fast_API__Routes):                          # Hash reconstruction
    tag                        : str                       = 'hashes'
    html_direct_transformations: Html__Direct__Transformations = None
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.html_direct_transformations = Html__Direct__Transformations()
    
    def to__html(self, request: Schema__Hashes__To__Html__Request
                  ) -> HTMLResponse:
        # Merge hash_mapping into html_dict
        modified_dict = self._apply_hash_mapping(request.html_dict, request.hash_mapping)
        
        # Reconstruct HTML
        html = self.html_direct_transformations.html_dict__to__html(modified_dict)
        
        return HTMLResponse(content=html, status_code=200)
    
    def _apply_hash_mapping(self, html_dict: Dict               ,# Apply hash replacements
                                  hash_mapping: Dict[str, str]
                            ) -> Dict:
        # Implementation: traverse html_dict, replace text nodes where hash matches
        # This is how external services (Semantic_Text) modify HTML
        pass
    
    def setup_routes(self):
        self.add_route_post(self.to__html)
```

---

## Round-Trip Validation Pattern

### Why Round-Trip Matters

The round-trip transformation (HTML → dict → HTML) is the **critical quality metric** for this service. If the round-trip is lossy, all transformations are suspect.

**Quality Characteristics:**
- **Lossless:** Reconstructed HTML should be functionally identical
- **Character-accurate:** Ideally byte-for-byte identical
- **Structure-preserving:** DOM structure must be maintained
- **Whitespace-handling:** Document whitespace preservation policy

### Round-Trip Testing

```python
class test_Routes__Html__Round_Trip(TestCase):
    
    @classmethod
    def setUpClass(cls):
        cls.client = TestClient(app)
        
    def test__round_trip__simple_html(self):                     # Basic validation
        original_html = "<html><body><p>Hello World</p></body></html>"
        
        response = self.client.post('/html/to/html', 
                                   json={'html': original_html})
        
        assert response.status_code    == 200
        reconstructed_html = response.text
        
        # Ideally: exact match
        assert reconstructed_html == original_html
        
    def test__round_trip__complex_wikipedia(self):               # Real-world test
        # Load actual Wikipedia page HTML
        original_html = load_file('tests/fixtures/wikipedia_page.html')
        
        response = self.client.post('/html/to/html',
                                   json={'html': original_html})
        
        reconstructed_html = response.text
        
        # Measure fidelity
        similarity = self._calculate_similarity(original_html, reconstructed_html)
        assert similarity > 0.95                                 # 95% similarity threshold
        
    def test__round_trip__with_text_extraction(self):            # Full pipeline test
        original_html = load_file('tests/fixtures/bbc_article.html')
        
        # Step 1: Extract text nodes
        response1 = self.client.post('/html/to/text/nodes',
                                    json={'html': original_html})
        text_nodes = response1.json()['text_nodes']
        
        # Step 2: Get html_dict
        response2 = self.client.post('/html/to/dict',
                                    json={'html': original_html})
        html_dict = response2.json()['html_dict']
        
        # Step 3: Reconstruct with no modifications
        response3 = self.client.post('/hashes/to/html',
                                    json={'html_dict': html_dict,
                                          'hash_mapping': {}})  # Empty = no changes
        
        reconstructed_html = response3.text
        
        # Should be very close to original
        similarity = self._calculate_similarity(original_html, reconstructed_html)
        assert similarity > 0.95
```

---

## Caching Strategy (Caller's Responsibility)

### Why No Built-In Caching?

**Previous design:** Service cached HTML, html_dict, text_nodes, ratings  
**New design:** Service has NO caching

**Rationale:**
1. **Separation of concerns:** Service transforms, caller caches
2. **Flexibility:** Callers have different caching needs (Redis, S3, memory)
3. **Simplicity:** Service code is simpler, faster to test
4. **Scalability:** Caching layer scales independently
5. **External cache service:** `MGraph-AI__Service__Cache` exists for this purpose

### Recommended Caller Caching Strategy

```python
# Example: Mitmproxy addon using this service

class MGraph_Html_Processor:
    
    def __init__(self):
        self.html_service = HttpClient("https://html.mgraph.ai")
        self.cache_service = HttpClient("https://cache.mgraph.ai")
        self.semantic_service = HttpClient("https://semantic-text.mgraph.ai")
    
    def process_intercepted_html(self, url: str, html: str):
        # Step 1: Check cache for html_dict
        cache_key_dict = f"html_dict:{hash_url(url)}"
        html_dict = self.cache_service.get(cache_key_dict)
        
        if not html_dict:
            # Cache miss: parse HTML
            response = self.html_service.post('/html/to/dict', 
                                             json={'html': html})
            html_dict = response.json()['html_dict']
            
            # Cache for 1 hour (structure rarely changes)
            self.cache_service.set(cache_key_dict, html_dict, ttl=3600)
        
        # Step 2: Check cache for text_nodes
        cache_key_nodes = f"text_nodes:{hash_url(url)}"
        text_nodes = self.cache_service.get(cache_key_nodes)
        
        if not text_nodes:
            # Cache miss: extract text
            response = self.html_service.post('/dict/to/text/nodes',
                                             json={'html_dict': html_dict})
            text_nodes = response.json()['text_nodes']
            
            # Cache indefinitely (hashes are stable)
            self.cache_service.set(cache_key_nodes, text_nodes, ttl=86400)
        
        # Step 3: Get ratings (external service)
        cache_key_ratings = f"ratings:{hash_text_nodes(text_nodes)}"
        ratings = self.cache_service.get(cache_key_ratings)
        
        if not ratings:
            # Cache miss: call semantic service
            response = self.semantic_service.post('/text/to/ratings',
                                                 json={'text_nodes': text_nodes})
            ratings = response.json()['ratings']
            
            # Cache for 1 week (ratings are expensive)
            self.cache_service.set(cache_key_ratings, ratings, ttl=604800)
        
        # Step 4: Apply filtering
        filtered_html = self._apply_filters(html_dict, ratings)
        
        return filtered_html
```

---

## FastAPI Application Setup

### Main FastAPI Class

```python
from osbot_fast_api.api.routes.Routes__Set_Cookie                import Routes__Set_Cookie
from osbot_fast_api_serverless.fast_api.Serverless__Fast_API     import Serverless__Fast_API
from osbot_fast_api_serverless.fast_api.routes.Routes__Info      import Routes__Info
from mgraph_ai_service_html.html__fast_api.routes.Routes__Html   import Routes__Html
from mgraph_ai_service_html.html__fast_api.routes.Routes__Dict   import Routes__Dict
from mgraph_ai_service_html.html__fast_api.routes.Routes__Hashes import Routes__Hashes

class Html__Fast_API(Serverless__Fast_API):                      # Main FastAPI application
    
    def setup_routes(self):
        self.add_routes(Routes__Html      )                      # HTML transformation routes
        self.add_routes(Routes__Dict      )                      # Dict operation routes
        self.add_routes(Routes__Hashes    )                      # Hash reconstruction routes
        self.add_routes(Routes__Info      )                      # Service info
        self.add_routes(Routes__Set_Cookie)                      # Utility routes
```

### Lambda Handler

```python
from osbot_aws.aws.lambda_.boto3__lambda import load_dependencies

LAMBDA_DEPENDENCIES__HTML_SERVICE = ['osbot-fast-api-serverless==v1.19.0',
                                     'memory-fs==v0.24.0'                ]

load_dependencies(LAMBDA_DEPENDENCIES__HTML_SERVICE)

def clear_osbot_modules():
    import sys
    for module in list(sys.modules):
        if module.startswith('osbot_aws'):
            del sys.modules[module]

clear_osbot_modules()

from mgraph_ai_service_html.html__fast_api.Html__Fast_API import Html__Fast_API

with Html__Fast_API() as _:
    _.setup()
    handler = _.handler()
    app     = _.app()

def run(event, context=None):
    return handler(event, context)
```

---

## Testing Requirements

### Test Structure

```
tests/
├── unit/
│   ├── html__fast_api/
│   │   ├── routes/
│   │   │   ├── test_Routes__Html.py                            # Route endpoint tests
│   │   │   ├── test_Routes__Dict.py
│   │   │   └── test_Routes__Hashes.py
│   │   └── core/
│   │       ├── test_Html__Extract_Text_Nodes.py                # Core component tests
│   │       └── test_Html__Direct__Transformations.py
│   └── schemas/
│       ├── test_Schema__Html__Requests.py                      # Schema validation tests
│       └── test_Schema__Html__Responses.py
└── integration/
    ├── test_Round_Trip_Validation.py                           # Critical quality tests
    └── test_FastAPI__Lambda.py                                 # Lambda deployment tests
```

### Critical Test Cases

```python
class test_Routes__Html(TestCase):
    
    @classmethod
    def setUpClass(cls):
        cls.client = TestClient(app)
    
    def test__to__dict(self):                                    # Test atomic parsing
        html = "<html><body><p>Test</p></body></html>"
        
        response = self.client.post('/html/to/dict', 
                                   json={'html': html})
        
        assert response.status_code == 200
        result = response.json()
        
        assert 'html_dict'  in result
        assert 'node_count' in result
        assert result['node_count'] > 0
    
    def test__to__html(self):                                    # Test round-trip
        html = "<html><body><p>Test</p></body></html>"
        
        response = self.client.post('/html/to/html',
                                   json={'html': html})
        
        assert response.status_code == 200
        reconstructed = response.text
        
        # Should be very similar to original
        assert '<p>Test</p>' in reconstructed
    
    def test__to__text__nodes(self):                             # Test extraction
        html = "<html><body><p>Hello</p><span>World</span></body></html>"
        
        response = self.client.post('/html/to/text/nodes',
                                   json={'html': html})
        
        assert response.status_code == 200
        result = response.json()
        
        assert 'text_nodes'   in result
        assert 'total_nodes'  in result
        assert result['total_nodes'] == 2                        # "Hello" and "World"
        
        # Verify hash structure
        text_nodes = result['text_nodes']
        for hash_value, node_data in text_nodes.items():
            assert 'text' in node_data
            assert 'tag'  in node_data
            assert len(hash_value) == 10                         # Default hash size

class test_Round_Trip_Validation(TestCase):
    
    def test__simple_html(self):                                 # Basic validation
        original = "<html><body>Test</body></html>"
        roundtrip = self._do_round_trip(original)
        assert original == roundtrip
    
    def test__complex_wikipedia(self):                           # Real-world test
        original = load_fixture('wikipedia_page.html')
        roundtrip = self._do_round_trip(original)
        similarity = calculate_similarity(original, roundtrip)
        assert similarity > 0.95                                 # 95% threshold
    
    def test__nested_structure(self):                            # Deep nesting
        original = self._generate_deeply_nested_html(depth=50)
        roundtrip = self._do_round_trip(original)
        assert self._same_structure(original, roundtrip)
    
    def _do_round_trip(self, html: str) -> str:
        response = self.client.post('/html/to/html', json={'html': html})
        return response.text
```

---

## Migration Strategy

### Phase 1: Parallel Deployment

1. **Deploy new service** as `MGraph-AI__Service__Html`
2. **Keep old service** running at existing endpoint
3. **Test with shadow traffic** - send requests to both, compare results
4. **Validate fidelity** - ensure round-trip quality matches or exceeds old service

### Phase 2: Client Migration

1. **Update Mitmproxy addon** to use new endpoints
2. **Integrate with Cache service** for html_dict/text_nodes caching
3. **Connect to Semantic_Text** service for ratings
4. **Monitor performance** - should see latency improvements (no LLM in critical path)

### Phase 3: Deprecation

1. **Mark old endpoints deprecated** with sunset headers
2. **Set deprecation date** (e.g., 3 months out)
3. **Remove old service** after all clients migrated

### Compatibility Notes

**Breaking changes:**
- Endpoints renamed (e.g., `/html-graphs/url-to-html` → `/html/to/dict`)
- Request/response formats changed (now use Type_Safe schemas)
- No built-in caching
- No LLM operations (moved to Semantic_Text service)

**Migration path:**
- Create adapter layer that translates old requests to new endpoints
- Deploy adapter alongside new service
- Gives clients time to update

---

## Type_Safe Patterns to Follow

### From the Guidance Documents

1. **Always inherit from Type_Safe**
2. **Type annotate everything** with Safe_* primitives
3. **Immutable defaults only** (no mutable defaults)
4. **Use context managers** with `_` in tests
5. **Inline comments aligned** at column 80
6. **NO docstrings** - breaks visual alignment
7. **Use .obj()** for comprehensive test assertions
8. **Ban raw primitives** - use Safe_Str, Safe_UInt, etc.

### Example Pattern

```python
class Schema__Example(Type_Safe):                                # Clear purpose comment
    text     : Safe_Str__Text                                    # Descriptive comment
    count    : Safe_UInt                                         # Aligned at column 80
    items    : List[Safe_Str]                                    # Auto-initializes to []
    optional : Safe_Str = None                                   # Explicitly nullable

# Test pattern
class test_Schema__Example(TestCase):
    
    def test__init__(self):                                      # Test initialization
        with Schema__Example() as _:
            assert type(_)       is Schema__Example
            assert type(_.text)  is Safe_Str__Text
            assert type(_.count) is Safe_UInt
            assert _.obj()       == __(text     = ''        ,    # Use .obj() for assertions
                                       count    = 0         ,
                                       items    = []        ,
                                       optional = None      )
```

---

## Implementation Checklist

### Core Components

- [ ] Create `Html__Direct__Transformations` class
- [ ] Modify `Html__Extract_Text_Nodes` to accept html_dict directly
- [ ] Remove all LLM-related classes
- [ ] Remove caching logic from `Html__Transformations`

### Schema Classes

- [ ] Create all request schemas with Type_Safe
- [ ] Create all response schemas with Type_Safe
- [ ] Validate all schemas use Safe_* primitives
- [ ] Add schema tests

### Routes

- [ ] Implement `Routes__Html` with all endpoints
- [ ] Implement `Routes__Dict` with all endpoints
- [ ] Implement `Routes__Hashes` with reconstruction logic
- [ ] Update `Html__Fast_API` to register new routes

### Testing

- [ ] Unit tests for each route endpoint
- [ ] Unit tests for core components
- [ ] Round-trip validation tests (critical!)
- [ ] Integration tests with Lambda deployment
- [ ] Performance benchmarks

### Documentation

- [ ] Update README with new service name and purpose
- [ ] Document endpoint usage patterns
- [ ] Create example client code
- [ ] Migration guide for existing users

### Deployment

- [ ] Update lambda handler
- [ ] Update deployment scripts
- [ ] Configure CloudWatch monitoring
- [ ] Set up API Gateway endpoints

---

## Success Criteria

1. **All endpoints operational** - 100% test coverage
2. **Round-trip fidelity >95%** on real-world HTML samples
3. **No LLM dependencies** in service code
4. **Performance improvement** - <100ms for html_dict conversion
5. **Type_Safe compliance** - all schemas properly typed
6. **Documentation complete** - API docs and examples
7. **Migration path clear** - clients know how to upgrade