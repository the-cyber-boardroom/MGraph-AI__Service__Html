# Iterative Flow Development (IFD) - LLM Brief

**Version**: 1.0  
**Purpose**: Quick reference guide for LLMs assisting with IFD-based development

---

## What is IFD?

Iterative Flow Development (IFD) is a methodology for rapid software development using AI assistance while maintaining engineering rigor. It centers on **preserving developer flow state** while leveraging LLMs for code generation.

## Core Principles

### 1. **Flow State Preservation**
- Minimize context switching
- Developer focuses on UX and architecture
- LLM handles boilerplate and repetitive coding
- Work in focused 2-3 hour sessions

### 2. **Dual-Mode Flexibility**

**Vibe Coding Mode** (Rapid Prototyping):
- Non-technical users describe desired functionality
- AI directly creates and modifies code
- Focus purely on "does it work?"
- Perfect for exploration and initial versions

**Air-Gapped Mode** (Professional Development):
- Developer manually reviews all AI suggestions
- Deliberate separation between AI and codebase
- Maintains code ownership and security
- Required for production systems

### 3. **Version Independence**
- Each version is completely self-contained
- NO shared code between versions (copy forward when needed)
- Build on **concepts**, not code
- Versions are isolated: `/versions/v0.1/`, `/versions/v0.2/`, etc.
- Major versions (v1.0, v2.0) consolidate proven minor versions

### 4. **UX-First Development**
- Define user experience before writing code
- Describe intended UX to the LLM
- Iterate based on user interaction, not technical perfection

### 5. **Real Data From Day One**
- NO mocked data or stubbed services
- Backend API must exist from v0.1
- Test with actual API calls immediately
- Catches integration issues early

### 6. **Progressive Enhancement**
```
v0.1 → Core MVP only (minimal functionality)
v0.2 → UI Polish
v0.3 → Data enhancements
v0.4 → Monitoring/logging
v0.5+ → Advanced features
v1.0 → Consolidation (proven features only)
```

### 7. **Zero External Dependencies**
- Use native web platform (ES6+ JavaScript)
- Web Components (custom elements)
- No frameworks (React/Vue/Angular)
- Browser APIs only (Fetch, DOM, etc.)
- Ensures longevity and simplicity

---

## Development Workflow

### Version Progression

**Minor Versions** (Incremental Development):
- v0.1, v0.2, v0.3... evolve within shared codebase
- Each adds focused features
- Potentially shippable at any point

**Major Versions** (Standalone Releases):
- v1.0: Consolidation of last minor version (e.g., v0.9)
- NO functional changes during consolidation
- Pure extraction and cleanup
- What stakeholders test (v0.9) is what gets deployed (v1.0)

### When Creating New Features

1. **Start with UX Description**
   ```
   "Create a chat interface with:
   - Resizable textarea
   - Live character count
   - Send on Enter (Shift+Enter for newline)
   - Disabled send button when empty"
   ```

2. **LLM Generates Initial Code**
   - Component structure
   - HTML template
   - Event handlers
   - CSS styling

3. **Human Refines**
   - Review and integrate (air-gapped) OR approve changes (vibe mode)
   - Test with real backend
   - Iterate on UX details
   - Add edge case handling

4. **Progressive Improvement**
   - v0.1: Basic functionality
   - v0.2: Add input validation
   - v0.3: Add error handling
   - v0.4: Optimize performance

---

## Technical Architecture

### Web Components Structure

```javascript
class MyComponent extends HTMLElement {
    constructor() {
        super();
        // Initialize state
        this.state = { /* component state */ };
    }
    
    connectedCallback() {
        this.render();
        this.setupEventListeners();
    }
    
    disconnectedCallback() {
        this.cleanup();  // Remove event listeners
    }
    
    render() {
        this.innerHTML = `
            <!-- Component HTML -->
        `;
    }
    
    setupEventListeners() {
        // Attach event handlers
    }
    
    cleanup() {
        // Remove listeners to prevent memory leaks
    }
}

customElements.define('my-component', MyComponent);
```

### Component Communication

**Use Events, Not Direct Calls:**
```javascript
// Component A dispatches
this.dispatchEvent(new CustomEvent('data-changed', {
    detail: { value: newData },
    bubbles: true
}));

// Component B listens
document.addEventListener('data-changed', (e) => {
    console.log('Received:', e.detail.value);
});
```

### File Organization (Per Version)

```
/versions/v0.1/
├── index.html              # Entry point
├── components/
│   ├── chat-panel/
│   │   ├── chat-panel.js
│   │   └── chat-panel.css
│   └── user-list/
│       ├── user-list.js
│       └── user-list.css
├── services/
│   └── api-client.js       # API communication
├── utils/
│   └── helpers.js          # Utility functions
└── styles/
    └── main.css            # Global styles
```

---

## Critical Anti-Patterns to AVOID

❌ **Don't** create shared code between versions
❌ **Don't** use external JavaScript frameworks/libraries  
❌ **Don't** mock data or stub APIs
❌ **Don't** over-engineer in v0.1 (keep it minimal!)
❌ **Don't** add features without proving them first
❌ **Don't** break the air gap in air-gapped mode
❌ **Don't** add business logic to schema files

---

## Production Readiness Checklist

Before v1.0 consolidation, ensure:

**Code Quality:**
- ✅ Consistent error handling throughout
- ✅ Memory management (cleanup in `disconnectedCallback`)
- ✅ No console errors or warnings

**Architecture:**
- ✅ Clear separation of concerns
- ✅ Event-driven component communication  
- ✅ Components are self-contained

**Performance:**
- ✅ Lazy loading for heavy components
- ✅ Debouncing for rapid actions
- ✅ Caching for expensive operations

**Maintainability:**
- ✅ Intuitive file organization
- ✅ Documented component APIs
- ✅ Consistent naming conventions

---

## Common LLM Interaction Patterns

### Creating a New Component
```
Context: I'm building version v0.3 of a text analysis app using IFD methodology.

Task: Create a new Web Component called 'analysis-results' that:
- Displays analysis results from /api/analyze endpoint
- Shows word count, character count, and sentiment
- Has loading state while fetching
- Handles errors gracefully
- Emits 'analysis-complete' event when done

Requirements:
- ES6 class extending HTMLElement
- No external dependencies
- Include inline CSS
- Use Fetch API for HTTP calls
- Follow event-driven architecture
```

### Refactoring Existing Code
```
Context: Working on v0.4, refactoring the admin panel from v0.3.

Current: All HTML is inline in Flask routes at /mitm-proxy/*

Goal: Extract to IFD-style components in /versions/v0.4/admin/

Please:
1. Create separate component files for each section
2. Maintain all current functionality  
3. Follow IFD Web Components pattern
4. Keep event-driven architecture
5. Ensure backend API calls remain unchanged
```

### Adding Features to Existing Component
```
I have this chat-panel component (code below). Please add:
- Message history (store last 50 messages)
- Scroll to bottom on new message
- Show timestamp for each message
- Clear history button

[Paste existing component code]

Maintain the existing event structure and don't break current functionality.
```

---

## Key Success Factors

1. **Start Minimal**: v0.1 should be embarrassingly simple
2. **Prove Before Consolidate**: Features must work in minor versions before v1.0
3. **Test Continuously**: Use real APIs, click through UI constantly
4. **Iterate Quickly**: 15-30 minute cycles, not day-long features
5. **Stay in Flow**: If you're stuck on syntax, ask the LLM
6. **Copy, Don't Share**: Reuse by copying files forward, not importing across versions

---

## Typical Development Session

```
9:00 AM  - Start v0.3, define UX goals
9:15 AM  - Prompt LLM for new component
9:30 AM  - Integrate and test component
10:00 AM - Iterate on UI details
10:30 AM - Add API integration
11:00 AM - Test end-to-end with real data
11:30 AM - Commit v0.3, plan v0.4
```

**Result**: Working, potentially shippable version in 2-3 hours

---

## When to Use Which Mode

**Use Vibe Coding When:**
- Exploring ideas rapidly
- Non-technical stakeholders involved
- Early prototyping (v0.1-v0.3)
- Speed is more important than perfection

**Use Air-Gapped When:**
- Production systems
- Security-critical code
- Need full code review
- Refactoring existing systems
- Creating v1.0 consolidation

**Hybrid Approach:**
- v0.1-v0.3: Vibe coding (explore ideas)
- v0.4-v0.6: Air-gapped (refine for production)
- v1.0: Air-gapped consolidation

---

## Remember

**IFD is about maintaining your flow state.** The methodology exists to keep you focused on solving user problems, not fighting with tools or technical debt. Let the AI handle the boilerplate, you handle the creativity and decision-making.

**Version independence means freedom.** Experiment without fear. If v0.4 is a dead end, abandon it and build v0.5 from v0.3. No technical debt accumulates.

**Real data from day one means confidence.** When v1.0 ships, you know it works because you've been testing with real data since v0.1.

---

## Quick Reference

| Aspect | IFD Approach |
|--------|--------------|
| **Dependencies** | None (native web only) |
| **Components** | Web Components (custom elements) |
| **Communication** | CustomEvents (event-driven) |
| **State** | Component-local + event coordination |
| **Versions** | Independent, no shared code |
| **API** | Real from v0.1, no mocks |
| **Testing** | Manual + real data continuously |
| **AI Role** | Code generation + refinement |
| **Human Role** | Architecture + UX + decisions |

---

## Example: Complete Minimal Component

```javascript
// /versions/v0.1/components/simple-counter/simple-counter.js

class SimpleCounter extends HTMLElement {
    constructor() {
        super();
        this.count = 0;
    }
    
    connectedCallback() {
        this.render();
        this.querySelector('button').addEventListener('click', () => this.increment());
    }
    
    render() {
        this.innerHTML = `
            <div class="counter">
                <p>Count: <span class="count">${this.count}</span></p>
                <button>Increment</button>
            </div>
            <style>
                .counter { padding: 1rem; border: 1px solid #ccc; }
                button { padding: 0.5rem 1rem; }
            </style>
        `;
    }
    
    increment() {
        this.count++;
        this.querySelector('.count').textContent = this.count;
        
        // Notify others of state change
        this.dispatchEvent(new CustomEvent('count-changed', {
            detail: { count: this.count },
            bubbles: true
        }));
    }
}

customElements.define('simple-counter', SimpleCounter);
```

Usage:
```html
<!DOCTYPE html>
<html>
<head>
    <title>Counter App v0.1</title>
    <script src="components/simple-counter/simple-counter.js"></script>
</head>
<body>
    <simple-counter></simple-counter>
</body>
</html>
```

---

**This is IFD.** Simple, fast, maintainable, and built for flow.